#!/bin/bash

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—
# â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘
# â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘
# â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
# â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘
# â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Deep metadata cleaning | The tool that excited Edward Snowden
# Full Mode: ExifTool + ffmpeg
# Version: 2.4.1
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -euo pipefail

# Version (single source of truth - update here only)
export ADAMANTIUM_VERSION="2.6"

# Colores
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly GRAY='\033[0;90m'
readonly STYLE_BOLD='\033[1m'
readonly NC='\033[0m' # No Color

# Emojis y sÃ­mbolos
readonly CHECK="${GREEN}âœ…${NC}"
readonly CROSS="${RED}âŒ${NC}"
readonly ARROW="${CYAN}â†’${NC}"
readonly BULLET="${BLUE}â—${NC}"
readonly WARN="${YELLOW}âš ï¸${NC}"
readonly INFO="${CYAN}ğŸ’¡${NC}"
readonly CLEAN="${MAGENTA}ğŸ§¹${NC}"
readonly SHIELD="ğŸ›¡ï¸"
readonly FILE_ICON="ğŸ“"
readonly SIZE_ICON="ğŸ“Š"
readonly VIDEO_ICON="ğŸ¬"
readonly IMAGE_ICON="ğŸ–¼ï¸"
readonly PDF_ICON="ğŸ“„"
readonly OFFICE_ICON="ğŸ“"
readonly SPARKLES="âœ¨"
readonly SEARCH_ICON="ğŸ”"
readonly LOCATION_ICON="ğŸ“"
readonly CAMERA_ICON="ğŸ“·"
readonly COMPUTER_ICON="ğŸ’»"
readonly CALENDAR_ICON="ğŸ“…"
readonly TOOL_ICON="ğŸ”§"
readonly ARCHIVE_ICON="ğŸ“¦"
readonly CODE_ICON="ğŸ’»"
readonly SVG_ICON="ğŸ¨"

# Variables globales
TEMP_DIR=""
ORIGINAL_FILE=""
OUTPUT_FILE=""
FILE_TYPE=""
IS_MULTIMEDIA=false
DRY_RUN=false
VERIFY_HASH=false
CHECK_DUPLICATES=true

# Variables para batch mode
BATCH_MODE=false
BATCH_JOBS=0
BATCH_PATTERNS=()
BATCH_RECURSIVE=false
BATCH_CONFIRM=true
BATCH_VERBOSE=false
BATCH_QUIET=false

# Variables para interactive mode
INTERACTIVE_MODE=false

# Variables para archive mode (v1.4)
ARCHIVE_MODE=false
ARCHIVE_PASSWORD=""
ARCHIVE_PREVIEW=false

# Variables para v1.5 features
NOTIFY_MODE=false          # --notify flag for file manager integration
OUTPUT_SUFFIX="_clean"     # Default suffix (can be overridden by config)

# Variables para v2.1 features
SHOW_ONLY=false            # --show-only flag to display metadata without cleaning

# Variables para v2.2 features
EPUB_MODE=false            # Flag for EPUB processing
ARCHIVE_UNKNOWN_POLICY="skip"  # Policy for unknown files in archives: skip, warn, fail, include

# Variables para v2.3 features
TORRENT_MODE=false         # Flag for torrent processing
TORRENT_CLEAN_MODE="safe"  # Torrent cleaning mode: safe or aggressive
LIGHTWEIGHT_MODE=false     # Lightweight output mode

# Variables para v2.4 features (re-encoding)
REENCODE_MODE=false            # Flag for re-encoding
REENCODE_PRESET="medium"       # Quality preset: high, medium, low
REENCODE_CRF=""                # Custom CRF value (overrides preset)
REENCODE_VIDEO_CODEC="libx264" # Video codec: libx264, libx265, libsvtav1
REENCODE_AUDIO_CODEC="aac"     # Audio codec: aac, libopus, flac
REENCODE_CONTAINER=""          # Output container: mp4, mkv, webm (empty = keep original)
REENCODE_HW_ACCEL="auto"       # Hardware acceleration: auto, nvidia, amd, intel, cpu
REENCODE_NO_CONFIRM=false      # Skip re-encoding confirmation

# Variables para v2.6 features (Deep Clean + Forensic)
DEEP_CLEAN_ENABLED=false       # Enable deep cleaning (thumbnail, PDF linearization, video streams)
FORENSIC_REPORT_ENABLED=false  # Enable forensic reporting
FORENSIC_REPORT_FORMAT="json"  # Report format: json, dfxml, all
FORENSIC_MULTIHASH=false       # Calculate multiple hashes (MD5, SHA1, SHA256)
FORENSIC_CASE_ID=""            # Case ID for forensic reports
FORENSIC_EVIDENCE_ID=""        # Evidence ID for forensic reports
FORENSIC_OPERATOR=""           # Operator name for forensic reports

# Performance optimizations (v2.3)
declare -A MIME_CACHE=()   # Cache for MIME type detection

# VersiÃ³n mÃ­nima requerida de ExifTool (se actualiza automÃ¡ticamente desde upstream)
REQUIRED_EXIFTOOL_VERSION="13.39"
# Nota: ffmpeg no tiene versiÃ³n mÃ­nima fija - cada distro tiene su versiÃ³n vÃ¡lida en repos

# Archivo de cachÃ© para evitar verificar en cada ejecuciÃ³n
CACHE_FILE="$HOME/.adamantium_last_check"
CACHE_DURATION=86400  # 24 horas en segundos

# Variables de sistema
DISTRO=""
PACKAGE_MANAGER=""
PKG_INSTALL_CMD=""

# Variables de internacionalizaciÃ³n
LANG_CODE="en"  # Default: English

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SISTEMA DE INTERNACIONALIZACIÃ“N (i18n)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

detect_language() {
    # Detectar idioma del sistema desde variables de entorno
    local sys_lang="${LANG:-${LC_ALL:-en_US.UTF-8}}"

    if [[ "$sys_lang" =~ ^es ]]; then
        LANG_CODE="es"
    else
        LANG_CODE="en"
    fi
}

# Mensajes en espaÃ±ol
declare -A MSG_ES=(
    [ERROR_NO_FILE]="Error: Debes proporcionar un archivo"
    [USAGE]="Uso:"
    [EXAMPLES]="Ejemplos:"
    [OPTIONS]="Opciones:"
    [ERROR_FILE_NOT_EXISTS]="Error: El archivo '%s' no existe"
    [FILE_TO_PROCESS]="Archivo a procesar:"
    [TYPE_DETECTED]="Tipo detectado:"
    [PROCESSING]="Procesamiento:"
    [METADATA_BEFORE]="METADATOS ANTES DE LA LIMPIEZA"
    [METADATA_AFTER]="METADATOS DESPUÃ‰S DE LA LIMPIEZA"
    [STARTING_DEEP_CLEAN]="INICIANDO LIMPIEZA PROFUNDA"
    [CLEANING_WITH_EXIFTOOL]="Limpiando metadatos con"
    [DEEP_CLEAN_WITH_FFMPEG]="Limpieza profunda con"
    [REMOVING_METADATA_EXIFTOOL]="Eliminando metadatos con ExifTool"
    [REMOVING_CONTAINER_METADATA]="Eliminando metadatos del contenedor multimedia"
    [CLEANING_COMPLETED]="Limpieza completada exitosamente"
    [PROCESS_COMPLETED]="PROCESO COMPLETADO"
    [ORIGINAL_FILE]="Archivo original:"
    [CLEAN_FILE]="Archivo limpio:"
    [SIZE]="TamaÃ±o:"
    [ORIGINAL_PRESERVED]="El archivo original se ha preservado intacto"
    [NO_METADATA_FOUND]="No se encontraron metadatos"
    [METADATA_FIELDS_TOTAL]="Total de campos de metadatos:"
    [VERIFYING_EXIFTOOL]="Verificando ExifTool..."
    [VERIFYING_FFMPEG]="Verificando ffmpeg..."
    [EXIFTOOL_UPDATED]="ExifTool estÃ¡ actualizado"
    [FFMPEG_UPDATED]="disponible"
    [EXIFTOOL_OUTDATED]="ExifTool desactualizado:"
    [UPDATING_FROM_REPOS]="Actualizando desde repositorios..."
    [UPDATED_TO]="actualizado a"
    [FROM_REPOS]="desde repositorios"
    [TRYING_SYSTEM_REPOS]="Intentando con repositorios del sistema (puede ser versiÃ³n anterior)..."
    [UPDATE_ERROR]="Error al actualizar"
    [CONTINUING_CURRENT]="Continuando con versiÃ³n actual..."
    [INSTALLING_FROM_SOURCE]="Instalando ExifTool"
    [FROM_SOURCE_SITE]="desde fuente (exiftool.org)..."
    [DOWNLOAD_ERROR]="Error al descargar ExifTool"
    [INSTALLED_FROM_SOURCE]="instalado correctamente desde fuente"
    [POST_INSTALL_ERROR]="Error en la verificaciÃ³n post-instalaciÃ³n"
    [INSTALLING_BUILD_DEPS]="Instalando dependencias de compilaciÃ³n..."
    [BUILD_DEPS_ERROR]="Error al instalar dependencias de compilaciÃ³n"
    [HEADER_SUBTITLE]="Limpieza profunda de metadatos | La herramienta que emocionÃ³ a Edward Snowden"
    [MULTIMEDIA]="multimedia"
    [IMAGE]="imagen"
    [PDF]="pdf"
    [OFFICE_DOC]="documento office"
    [UNKNOWN]="desconocido"
    [EXIFTOOL_FFMPEG]="ExifTool + ffmpeg"
    [EXIFTOOL_ONLY]="ExifTool"
    [TOTAL]="Total"
    [SEPARATOR]="â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    [PACKAGE_MANAGER_NOT_DETECTED]="No se pudo detectar el gestor de paquetes"
    [DRY_RUN_MODE]="MODO SIMULACIÃ“N (DRY-RUN)"
    [DRY_RUN_NOTICE]="No se realizarÃ¡n cambios, solo previsualizaciÃ³n"
    [WOULD_CREATE]="Se crearÃ­a:"
    [HASH_VERIFICATION]="VERIFICACIÃ“N DE HASH"
    [HASH_ORIGINAL]="Hash original (SHA256):"
    [HASH_CLEAN]="Hash limpio (SHA256):"
    [HASH_DIFFERENT]="Los archivos son diferentes (limpieza exitosa)"
    [HASH_IDENTICAL]="ADVERTENCIA: Los hashes son idÃ©nticos (sin cambios)"
    [DUPLICATE_WARNING]="ADVERTENCIA: Este archivo parece ya estar limpio"
    [DUPLICATE_REASON]="No se encontraron metadatos sensibles"
    [DUPLICATE_CONTINUE]="Â¿Deseas continuar de todos modos?"
    [BATCH_MODE]="MODO POR LOTES"
    [BATCH_PROCESSING]="Procesamiento por lotes"
    [FILES_SELECTED]="archivos seleccionados"
    [FILES_FOUND]="Archivos encontrados"
    [SELECT_FILES]="Seleccionar archivos"
    [PATTERN]="PatrÃ³n"
    [JOBS]="Trabajos paralelos"
    [PROCESSING_FILE]="Procesando"
    [BATCH_SUMMARY]="RESUMEN DEL LOTE"
    [SUMMARY]="Resumen"
    [SUCCESSFUL]="Exitosos"
    [FAILED]="Fallidos"
    [ELAPSED_TIME]="Tiempo transcurrido"
    [AVERAGE_SPEED]="Velocidad promedio"
    [FILES_PER_SECOND]="archivos/seg"
    [INTERACTIVE_SELECT]="Usar TAB para seleccionar, ENTER para confirmar"
    [NO_FILES_MATCH]="No se encontraron archivos que coincidan con los patrones"
    [NO_FILES_TO_PROCESS]="No hay archivos para procesar"
    [SEARCHING_FILES]="Buscando archivos"
    [PROCEED_WITH_CLEANING]="Â¿Proceder con la limpieza?"
    [INTERACTIVE_WELCOME]="Bienvenido al modo interactivo de adamantium"
    [INTERACTIVE_MENU_TITLE]="MenÃº Principal"
    [INTERACTIVE_SINGLE_FILE]="Limpiar archivo individual"
    [INTERACTIVE_VIEW_METADATA]="Ver metadatos de archivo"
    [INTERACTIVE_BATCH]="Procesamiento por lotes"
    [INTERACTIVE_SETTINGS]="ConfiguraciÃ³n"
    [INTERACTIVE_HELP]="Ayuda"
    [INTERACTIVE_ABOUT]="Acerca de"
    [INTERACTIVE_EXIT]="Salir"
    [INTERACTIVE_SELECT_OPTION]="Selecciona una opciÃ³n"
    [INTERACTIVE_GOODBYE]="Â¡Hasta luego! Tu privacidad estÃ¡ protegida."
    [INTERACTIVE_ENTER_PATH]="Introduce la ruta del directorio"
    [INTERACTIVE_SELECT_FILE]="Selecciona un archivo"
    [ARCHIVE_DETECTED]="Archivo comprimido detectado"
    [ARCHIVE_FORMAT]="Formato"
    [ARCHIVE_PASSWORD_REQUIRED]="Este archivo requiere contraseÃ±a"
    [ARCHIVE_ENTER_PASSWORD]="Introduce la contraseÃ±a"
    [ARCHIVE_EXTRACTING]="Extrayendo contenidos"
    [ARCHIVE_CLEANING_CONTENTS]="Limpiando metadatos de contenidos"
    [ARCHIVE_RECOMPRESSING]="Recomprimiendo archivo"
    [ARCHIVE_FILES_CLEANED]="Archivos limpiados"
    [ARCHIVE_FILES_SKIPPED]="Archivos omitidos"
    [ARCHIVE_CONTENTS_PREVIEW]="Vista previa de contenidos"
    [ARCHIVE_CLEANABLE_FILES]="Archivos limpiables"
    [ARCHIVE_OTHER_FILES]="Otros archivos"
    [ARCHIVE_WRONG_PASSWORD]="ContraseÃ±a incorrecta"
    [ARCHIVE_RAR_TO_7Z]="RAR serÃ¡ convertido a 7Z (formato libre)"
    [ARCHIVE_NESTED]="Archivo anidado"
    [ARCHIVE_NESTED_PROCESSED]="Archivos anidados procesados"
    [ARCHIVE_UNSUPPORTED]="Formato de archivo no soportado"
    [ARCHIVE_EXTRACT_ERROR]="Error al extraer archivo"
    [ARCHIVE_RECOMPRESS_ERROR]="Error al recomprimir archivo"
    [ARCHIVE_PASSWORD_PROTECTED]="Protegido con contraseÃ±a"
    [INTERACTIVE_ARCHIVE]="Limpiar archivo comprimido"
    [SVG_FILE]="archivo SVG"
    [CSS_FILE]="archivo CSS"
    [SHOW_ONLY_MODE]="MODO SOLO VISUALIZACIÃ“N"
    [SHOW_ONLY_NOTICE]="Mostrando metadatos sin realizar limpieza"
    [CSS_COMMENTS_FOUND]="Comentarios CSS encontrados"
    [CSS_COMMENTS_REMOVED]="Todos los comentarios eliminados"
    [CSS_NO_COMMENTS]="No se encontraron comentarios CSS"
    [CLEANING_CSS]="Limpiando comentarios CSS"
    [EPUB_FILE]="archivo EPUB"
    [EPUB_DETECTED]="Ebook EPUB detectado"
    [EPUB_EXTRACTING]="Extrayendo EPUB"
    [EPUB_EXTRACTED]="EPUB extraÃ­do correctamente"
    [EPUB_CLEANING_OPF]="Limpiando metadatos OPF"
    [EPUB_OPF_CLEANED]="Metadatos OPF limpiados"
    [EPUB_CLEANING_NCX]="Limpiando metadatos NCX"
    [EPUB_NCX_CLEANED]="Metadatos NCX limpiados"
    [EPUB_CLEANING_IMAGES]="Limpiando imÃ¡genes internas"
    [EPUB_IMAGES_CLEANED]="ImÃ¡genes internas limpiadas"
    [EPUB_RECOMPRESSING]="Recomprimiendo EPUB"
    [EPUB_RECOMPRESSED]="EPUB recomprimido correctamente"
    [EPUB_CLEAN_SUCCESS]="EPUB limpiado exitosamente"
    [EPUB_EXTRACT_ERROR]="Error al extraer EPUB"
    [EPUB_RECOMPRESS_ERROR]="Error al recomprimir EPUB"
    [EPUB_INVALID]="Estructura de archivo EPUB invÃ¡lida"
    [EPUB_NO_OPF]="No se encontrÃ³ archivo OPF"
    [EPUB_OPF_FILE]="Archivo OPF"
    [EPUB_INTERNAL_IMAGES]="ImÃ¡genes internas"
    [UNKNOWN_POLICY_SKIP]="Omitiendo archivo de tipo desconocido"
    [UNKNOWN_POLICY_WARN]="Advertencia: Tipo de archivo desconocido"
    [UNKNOWN_POLICY_FAIL]="Error: Tipo de archivo desconocido, abortando"
    [UNKNOWN_POLICY_INCLUDE]="Incluyendo archivo desconocido sin limpiar"
    [TORRENT_FILE]="archivo torrent"
    [TORRENT_DETECTED]="Archivo BitTorrent detectado"
    [TORRENT_CLEANING]="Limpiando metadatos del torrent"
    [TORRENT_CLEANED]="Metadatos del torrent limpiados"
    [TORRENT_CLEAN_SUCCESS]="Torrent limpiado exitosamente"
    [TORRENT_CLEAN_ERROR]="Error al limpiar el torrent"
    [TORRENT_INVALID]="Archivo torrent invalido o corrupto"
    [TORRENT_REMOVED]="Eliminados"
    [TORRENT_PRESERVED]="Preservados"
    [TORRENT_MODE_SAFE]="Modo seguro: preserva funcionalidad del torrent"
    [TORRENT_MODE_AGGRESSIVE]="Modo agresivo: maxima privacidad"
    # Re-encoding messages (v2.4)
    [REENCODE_ESTIMATION_TITLE]="ESTIMACION DE RE-ENCODING"
    [REENCODE_CURRENT_CODEC]="Codec actual"
    [REENCODE_RESOLUTION]="Resolucion"
    [REENCODE_DURATION]="Duracion"
    [REENCODE_TARGET_CODEC]="Codec destino"
    [REENCODE_PRESET]="Preset de calidad"
    [REENCODE_HW_ACCEL]="Aceleracion hardware"
    [REENCODE_EST_TIME]="Tiempo estimado"
    [REENCODE_EST_SIZE]="Tamano estimado"
    [REENCODE_WARNING]="ADVERTENCIA: El re-encoding implica perdida de calidad"
    [REENCODE_WARNING_DETAIL]="El archivo sera completamente recodificado. Esta accion no se puede deshacer."
    [REENCODE_CONFIRM_PROMPT]="Continuar con el re-encoding?"
    [REENCODE_STARTING]="Iniciando re-encoding"
    [REENCODE_COMPLETED]="Re-encoding completado en"
    [REENCODE_FAILED]="Error durante el re-encoding"
    [REENCODE_CANCELLED]="Re-encoding cancelado por el usuario"
    [REENCODE_INVALID_COMBINATION]="Combinacion codec/contenedor invalida"
    [REENCODE_SUGGEST_MKV]="Sugerencia: usa MKV como contenedor (soporta todos los codecs)"
    # Risk analysis messages (v2.5)
    [RISK_ANALYSIS]="ANALISIS DE RIESGOS"
    [RISK_CRITICAL]="CRITICO"
    [RISK_WARNING]="ADVERTENCIA"
    [RISK_INFO]="INFO"
    [RISK_LOCATION]="Ubicacion"
    [RISK_IDENTITY]="Identidad"
    [RISK_CONTACT]="Contacto"
    [RISK_DEVICE_ID]="ID Dispositivo"
    [RISK_TRACKING]="Rastreo"
    [RISK_AI_PROMPT]="Prompt IA"
    [RISK_HISTORY]="Historial"
    [RISK_SOFTWARE]="Software"
    [RISK_TIMESTAMP]="Marca de tiempo"
    [RISK_HARDWARE]="Hardware"
    [RISK_DOCUMENT]="Documento"
    [RISK_TOTAL_FOUND]="campos de metadatos potencialmente peligrosos detectados"
    [RISK_VIEW_DETAILS]="Ver detalles de riesgos"
    [RISK_FIELD]="Campo"
    [RISK_VALUE]="Valor"
    [RISK_LEVEL]="Nivel"
    [RISK_CATEGORY]="Categoria"
    [DEEP_CLEAN_PROCESSING]="Realizando limpieza profunda..."
    [FORENSIC_REPORT_GENERATED]="Reporte forense generado"
)

# Mensajes en inglÃ©s (idioma por defecto)
declare -A MSG_EN=(
    [ERROR_NO_FILE]="Error: You must provide a file"
    [USAGE]="Usage:"
    [EXAMPLES]="Examples:"
    [OPTIONS]="Options:"
    [ERROR_FILE_NOT_EXISTS]="Error: File '%s' does not exist"
    [FILE_TO_PROCESS]="File to process:"
    [TYPE_DETECTED]="Detected type:"
    [PROCESSING]="Processing:"
    [METADATA_BEFORE]="METADATA BEFORE CLEANING"
    [METADATA_AFTER]="METADATA AFTER CLEANING"
    [STARTING_DEEP_CLEAN]="STARTING DEEP CLEANING"
    [CLEANING_WITH_EXIFTOOL]="Cleaning metadata with"
    [DEEP_CLEAN_WITH_FFMPEG]="Deep cleaning with"
    [REMOVING_METADATA_EXIFTOOL]="Removing metadata with ExifTool"
    [REMOVING_CONTAINER_METADATA]="Removing multimedia container metadata"
    [CLEANING_COMPLETED]="Cleaning completed successfully"
    [PROCESS_COMPLETED]="PROCESS COMPLETED"
    [ORIGINAL_FILE]="Original file:"
    [CLEAN_FILE]="Clean file:"
    [SIZE]="Size:"
    [ORIGINAL_PRESERVED]="The original file has been preserved intact"
    [NO_METADATA_FOUND]="No metadata found"
    [METADATA_FIELDS_TOTAL]="Total metadata fields:"
    [VERIFYING_EXIFTOOL]="Verifying ExifTool..."
    [VERIFYING_FFMPEG]="Verifying ffmpeg..."
    [EXIFTOOL_UPDATED]="ExifTool is up to date"
    [FFMPEG_UPDATED]="available"
    [EXIFTOOL_OUTDATED]="ExifTool outdated:"
    [UPDATING_FROM_REPOS]="Updating from repositories..."
    [UPDATED_TO]="updated to"
    [FROM_REPOS]="from repositories"
    [TRYING_SYSTEM_REPOS]="Trying system repositories (may be older version)..."
    [UPDATE_ERROR]="Error updating"
    [CONTINUING_CURRENT]="Continuing with current version..."
    [INSTALLING_FROM_SOURCE]="Installing ExifTool"
    [FROM_SOURCE_SITE]="from source (exiftool.org)..."
    [DOWNLOAD_ERROR]="Error downloading ExifTool"
    [INSTALLED_FROM_SOURCE]="installed correctly from source"
    [POST_INSTALL_ERROR]="Post-installation verification error"
    [INSTALLING_BUILD_DEPS]="Installing build dependencies..."
    [BUILD_DEPS_ERROR]="Error installing build dependencies"
    [HEADER_SUBTITLE]="Deep metadata cleaning | The tool that excited Edward Snowden"
    [MULTIMEDIA]="multimedia"
    [IMAGE]="image"
    [PDF]="pdf"
    [OFFICE_DOC]="office document"
    [UNKNOWN]="unknown"
    [EXIFTOOL_FFMPEG]="ExifTool + ffmpeg"
    [EXIFTOOL_ONLY]="ExifTool"
    [TOTAL]="Total"
    [SEPARATOR]="â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    [PACKAGE_MANAGER_NOT_DETECTED]="Could not detect package manager"
    [DRY_RUN_MODE]="DRY-RUN MODE (SIMULATION)"
    [DRY_RUN_NOTICE]="No changes will be made, preview only"
    [WOULD_CREATE]="Would create:"
    [HASH_VERIFICATION]="HASH VERIFICATION"
    [HASH_ORIGINAL]="Original hash (SHA256):"
    [HASH_CLEAN]="Clean hash (SHA256):"
    [HASH_DIFFERENT]="Files are different (cleaning successful)"
    [HASH_IDENTICAL]="WARNING: Hashes are identical (no changes)"
    [DUPLICATE_WARNING]="WARNING: This file appears to be already clean"
    [DUPLICATE_REASON]="No sensitive metadata found"
    [DUPLICATE_CONTINUE]="Do you want to continue anyway?"
    [BATCH_MODE]="BATCH MODE"
    [BATCH_PROCESSING]="Batch processing"
    [FILES_SELECTED]="files selected"
    [FILES_FOUND]="Files found"
    [SELECT_FILES]="Select files"
    [PATTERN]="Pattern"
    [JOBS]="Parallel jobs"
    [PROCESSING_FILE]="Processing"
    [BATCH_SUMMARY]="BATCH SUMMARY"
    [SUMMARY]="Summary"
    [SUCCESSFUL]="Successful"
    [FAILED]="Failed"
    [ELAPSED_TIME]="Elapsed time"
    [AVERAGE_SPEED]="Average speed"
    [FILES_PER_SECOND]="files/sec"
    [INTERACTIVE_SELECT]="Use TAB to select, ENTER to confirm"
    [NO_FILES_MATCH]="No files match the patterns"
    [NO_FILES_TO_PROCESS]="No files to process"
    [SEARCHING_FILES]="Searching for files"
    [PROCEED_WITH_CLEANING]="Proceed with cleaning?"
    [INTERACTIVE_WELCOME]="Welcome to adamantium interactive mode"
    [INTERACTIVE_MENU_TITLE]="Main Menu"
    [INTERACTIVE_SINGLE_FILE]="Clean single file"
    [INTERACTIVE_VIEW_METADATA]="View file metadata"
    [INTERACTIVE_BATCH]="Batch processing"
    [INTERACTIVE_SETTINGS]="Settings"
    [INTERACTIVE_HELP]="Help"
    [INTERACTIVE_ABOUT]="About"
    [INTERACTIVE_EXIT]="Exit"
    [INTERACTIVE_SELECT_OPTION]="Select an option"
    [INTERACTIVE_GOODBYE]="Goodbye! Your privacy is protected."
    [INTERACTIVE_ENTER_PATH]="Enter directory path"
    [INTERACTIVE_SELECT_FILE]="Select a file"
    [ARCHIVE_DETECTED]="Compressed archive detected"
    [ARCHIVE_FORMAT]="Format"
    [ARCHIVE_PASSWORD_REQUIRED]="This archive requires a password"
    [ARCHIVE_ENTER_PASSWORD]="Enter password"
    [ARCHIVE_EXTRACTING]="Extracting contents"
    [ARCHIVE_CLEANING_CONTENTS]="Cleaning metadata from contents"
    [ARCHIVE_RECOMPRESSING]="Recompressing archive"
    [ARCHIVE_FILES_CLEANED]="Files cleaned"
    [ARCHIVE_FILES_SKIPPED]="Files skipped"
    [ARCHIVE_CONTENTS_PREVIEW]="Archive contents preview"
    [ARCHIVE_CLEANABLE_FILES]="Cleanable files"
    [ARCHIVE_OTHER_FILES]="Other files"
    [ARCHIVE_WRONG_PASSWORD]="Wrong password"
    [ARCHIVE_RAR_TO_7Z]="RAR will be converted to 7Z (open format)"
    [ARCHIVE_NESTED]="Nested archive"
    [ARCHIVE_NESTED_PROCESSED]="Nested archives processed"
    [ARCHIVE_UNSUPPORTED]="Unsupported archive format"
    [ARCHIVE_EXTRACT_ERROR]="Error extracting archive"
    [ARCHIVE_RECOMPRESS_ERROR]="Error recompressing archive"
    [ARCHIVE_PASSWORD_PROTECTED]="Password protected"
    [INTERACTIVE_ARCHIVE]="Clean compressed archive"
    [SVG_FILE]="SVG file"
    [CSS_FILE]="CSS file"
    [SHOW_ONLY_MODE]="SHOW-ONLY MODE"
    [SHOW_ONLY_NOTICE]="Displaying metadata without cleaning"
    [CSS_COMMENTS_FOUND]="CSS comments found"
    [CSS_COMMENTS_REMOVED]="All comments removed"
    [CSS_NO_COMMENTS]="No CSS comments found"
    [CLEANING_CSS]="Cleaning CSS comments"
    [EPUB_FILE]="EPUB file"
    [EPUB_DETECTED]="EPUB ebook detected"
    [EPUB_EXTRACTING]="Extracting EPUB"
    [EPUB_EXTRACTED]="EPUB extracted successfully"
    [EPUB_CLEANING_OPF]="Cleaning OPF metadata"
    [EPUB_OPF_CLEANED]="OPF metadata cleaned"
    [EPUB_CLEANING_NCX]="Cleaning NCX metadata"
    [EPUB_NCX_CLEANED]="NCX metadata cleaned"
    [EPUB_CLEANING_IMAGES]="Cleaning internal images"
    [EPUB_IMAGES_CLEANED]="Internal images cleaned"
    [EPUB_RECOMPRESSING]="Recompressing EPUB"
    [EPUB_RECOMPRESSED]="EPUB recompressed successfully"
    [EPUB_CLEAN_SUCCESS]="EPUB cleaned successfully"
    [EPUB_EXTRACT_ERROR]="Error extracting EPUB"
    [EPUB_RECOMPRESS_ERROR]="Error recompressing EPUB"
    [EPUB_INVALID]="Invalid EPUB file structure"
    [EPUB_NO_OPF]="OPF file not found"
    [EPUB_OPF_FILE]="OPF file"
    [EPUB_INTERNAL_IMAGES]="Internal images"
    [UNKNOWN_POLICY_SKIP]="Skipping unknown file type"
    [UNKNOWN_POLICY_WARN]="Warning: Unknown file type"
    [UNKNOWN_POLICY_FAIL]="Error: Unknown file type, aborting"
    [UNKNOWN_POLICY_INCLUDE]="Including unknown file without cleaning"
    [TORRENT_FILE]="torrent file"
    [TORRENT_DETECTED]="BitTorrent file detected"
    [TORRENT_CLEANING]="Cleaning torrent metadata"
    [TORRENT_CLEANED]="Torrent metadata cleaned"
    [TORRENT_CLEAN_SUCCESS]="Torrent cleaned successfully"
    [TORRENT_CLEAN_ERROR]="Error cleaning torrent"
    [TORRENT_INVALID]="Invalid or corrupt torrent file"
    [TORRENT_REMOVED]="Removed"
    [TORRENT_PRESERVED]="Preserved"
    [TORRENT_MODE_SAFE]="Safe mode: preserves torrent functionality"
    [TORRENT_MODE_AGGRESSIVE]="Aggressive mode: maximum privacy"
    # Re-encoding messages (v2.4)
    [REENCODE_ESTIMATION_TITLE]="RE-ENCODING ESTIMATION"
    [REENCODE_CURRENT_CODEC]="Current codec"
    [REENCODE_RESOLUTION]="Resolution"
    [REENCODE_DURATION]="Duration"
    [REENCODE_TARGET_CODEC]="Target codec"
    [REENCODE_PRESET]="Quality preset"
    [REENCODE_HW_ACCEL]="Hardware acceleration"
    [REENCODE_EST_TIME]="Estimated time"
    [REENCODE_EST_SIZE]="Estimated size"
    [REENCODE_WARNING]="WARNING: Re-encoding implies quality loss"
    [REENCODE_WARNING_DETAIL]="The file will be completely re-encoded. This action cannot be undone."
    [REENCODE_CONFIRM_PROMPT]="Continue with re-encoding?"
    [REENCODE_STARTING]="Starting re-encoding"
    [REENCODE_COMPLETED]="Re-encoding completed in"
    [REENCODE_FAILED]="Re-encoding failed"
    [REENCODE_CANCELLED]="Re-encoding cancelled by user"
    [REENCODE_INVALID_COMBINATION]="Invalid codec/container combination"
    [REENCODE_SUGGEST_MKV]="Suggestion: use MKV as container (supports all codecs)"
    # Risk analysis messages (v2.5)
    [RISK_ANALYSIS]="RISK ANALYSIS"
    [RISK_CRITICAL]="CRITICAL"
    [RISK_WARNING]="WARNING"
    [RISK_INFO]="INFO"
    [RISK_LOCATION]="Location"
    [RISK_IDENTITY]="Identity"
    [RISK_CONTACT]="Contact"
    [RISK_DEVICE_ID]="Device ID"
    [RISK_TRACKING]="Tracking"
    [RISK_AI_PROMPT]="AI Prompt"
    [RISK_HISTORY]="History"
    [RISK_SOFTWARE]="Software"
    [RISK_TIMESTAMP]="Timestamp"
    [RISK_HARDWARE]="Hardware"
    [RISK_DOCUMENT]="Document"
    [RISK_TOTAL_FOUND]="potentially dangerous metadata fields detected"
    [RISK_VIEW_DETAILS]="View risk details"
    [RISK_FIELD]="Field"
    [RISK_VALUE]="Value"
    [RISK_LEVEL]="Risk"
    [RISK_CATEGORY]="Category"
    [DEEP_CLEAN_PROCESSING]="Performing deep cleaning..."
    [FORENSIC_REPORT_GENERATED]="Forensic report generated"
)

# FunciÃ³n para obtener mensaje traducido
msg() {
    local key="$1"
    shift
    local text

    if [ "$LANG_CODE" = "es" ]; then
        text="${MSG_ES[$key]}"
    else
        text="${MSG_EN[$key]}"
    fi

    # Si tiene parÃ¡metros, aplicar printf
    if [ $# -gt 0 ]; then
        printf "$text" "$@"
    else
        echo "$text"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DETECCIÃ“N DE DISTRIBUCIÃ“N Y GESTOR DE PAQUETES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

detect_system() {
    # Detectar distribuciÃ³n
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO="$ID"
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        DISTRO="$DISTRIB_ID"
    else
        DISTRO="unknown"
    fi

    # Detectar gestor de paquetes
    if command -v pacman &>/dev/null; then
        PACKAGE_MANAGER="pacman"
        PKG_INSTALL_CMD="sudo pacman -S --noconfirm"
    elif command -v apt-get &>/dev/null; then
        PACKAGE_MANAGER="apt"
        PKG_INSTALL_CMD="sudo apt-get install -y"
    elif command -v dnf &>/dev/null; then
        PACKAGE_MANAGER="dnf"
        PKG_INSTALL_CMD="sudo dnf install -y"
    elif command -v yum &>/dev/null; then
        PACKAGE_MANAGER="yum"
        PKG_INSTALL_CMD="sudo yum install -y"
    elif command -v zypper &>/dev/null; then
        PACKAGE_MANAGER="zypper"
        PKG_INSTALL_CMD="sudo zypper install -y"
    elif command -v apk &>/dev/null; then
        PACKAGE_MANAGER="apk"
        PKG_INSTALL_CMD="sudo apk add"
    else
        PACKAGE_MANAGER="unknown"
        PKG_INSTALL_CMD=""
    fi
}

get_package_name() {
    local pkg="$1"

    case "$pkg" in
        exiftool)
            case "$PACKAGE_MANAGER" in
                pacman) echo "perl-image-exiftool" ;;
                apt) echo "libimage-exiftool-perl" ;;
                dnf|yum) echo "perl-Image-ExifTool" ;;
                zypper) echo "exiftool" ;;
                apk) echo "exiftool" ;;
                *) echo "exiftool" ;;
            esac
            ;;
        ffmpeg)
            echo "ffmpeg"  # Mismo nombre en todas las distros
            ;;
        perl-makemaker)
            # Necesario para compilar ExifTool desde fuente
            case "$PACKAGE_MANAGER" in
                pacman) echo "base-devel" ;;  # Arch incluye MakeMaker en perl
                apt) echo "perl-modules" ;;
                dnf|yum) echo "perl-ExtUtils-MakeMaker" ;;
                zypper) echo "perl-ExtUtils-MakeMaker" ;;
                apk) echo "perl-utils" ;;
                *) echo "perl-ExtUtils-MakeMaker" ;;
            esac
            ;;
        *)
            echo "$pkg"
            ;;
    esac
}

install_package() {
    local pkg="$1"
    local pkg_name=$(get_package_name "$pkg")

    if [ -z "$PKG_INSTALL_CMD" ]; then
        echo -e "${RED}${CROSS}${NC} $(msg PACKAGE_MANAGER_NOT_DETECTED)"
        return 1
    fi

    # Actualizar repos si es necesario
    case "$PACKAGE_MANAGER" in
        pacman)
            sudo pacman -Sy &>/dev/null
            ;;
        apt)
            sudo apt-get update &>/dev/null
            ;;
    esac

    # Instalar paquete
    $PKG_INSTALL_CMD "$pkg_name" &>/dev/null
    return $?
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE ACTUALIZACIÃ“N AUTOMÃTICA HÃBRIDA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

should_check_updates() {
    # Verificar si hace mÃ¡s de 24h desde la Ãºltima verificaciÃ³n
    if [ ! -f "$CACHE_FILE" ]; then
        return 0  # No existe cachÃ©, verificar
    fi

    local last_check=$(cat "$CACHE_FILE" 2>/dev/null || echo "0")
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_check))

    if [ "$time_diff" -gt "$CACHE_DURATION" ]; then
        return 0  # MÃ¡s de 24h, verificar
    else
        return 1  # Menos de 24h, skip
    fi
}

update_cache() {
    date +%s > "$CACHE_FILE"
}

get_latest_exiftool_version() {
    # Obtener Ãºltima versiÃ³n desde exiftool.org
    local version
    version=$(curl -s "https://exiftool.org/ver.txt" 2>/dev/null | head -1 | tr -d '\r\n' | grep -oP '[0-9]+\.[0-9]+')

    if [ -z "$version" ]; then
        # Fallback: parsear desde la pÃ¡gina principal
        version=$(curl -s "https://exiftool.org/" 2>/dev/null | grep -oP 'Version [0-9]+\.[0-9]+' | head -1 | grep -oP '[0-9]+\.[0-9]+')
    fi

    echo "${version:-$REQUIRED_EXIFTOOL_VERSION}"
}

compare_versions() {
    # Compara dos versiones en formato X.Y
    # Retorna 0 si $1 >= $2, 1 si $1 < $2
    local v1=$1
    local v2=$2

    if [ "$v1" = "$v2" ]; then
        return 0
    fi

    local v1_major=$(echo "$v1" | cut -d. -f1)
    local v1_minor=$(echo "$v1" | cut -d. -f2)
    local v2_major=$(echo "$v2" | cut -d. -f1)
    local v2_minor=$(echo "$v2" | cut -d. -f2)

    if [ "$v1_major" -gt "$v2_major" ]; then
        return 0
    elif [ "$v1_major" -lt "$v2_major" ]; then
        return 1
    fi

    # Major iguales, comparar minor
    if [ "$v1_minor" -ge "$v2_minor" ]; then
        return 0
    else
        return 1
    fi
}

install_exiftool_from_source() {
    local target_version=$1
    local temp_dir=$(mktemp -d)
    local original_dir="$(pwd 2>/dev/null || echo /)"

    echo -e "${CYAN}${ARROW}${NC} $(msg INSTALLING_FROM_SOURCE) ${WHITE}${target_version}${NC} $(msg FROM_SOURCE_SITE)"

    # Verificar e instalar dependencias de compilaciÃ³n si faltan
    if ! perl -e 'use ExtUtils::MakeMaker' &>/dev/null; then
        echo -e "${GRAY}   $(msg INSTALLING_BUILD_DEPS)${NC}"
        if ! install_package "perl-makemaker"; then
            echo -e "${RED}${CROSS}${NC} $(msg BUILD_DEPS_ERROR)"
            return 1
        fi
    fi

    cd "$temp_dir" || { cd "$original_dir" 2>/dev/null || cd /; return 1; }

    # Descargar
    if ! wget -q "https://exiftool.org/Image-ExifTool-${target_version}.tar.gz" 2>/dev/null; then
        echo -e "${RED}${CROSS}${NC} $(msg DOWNLOAD_ERROR) ${target_version}"
        cd "$original_dir" 2>/dev/null || cd /
        rm -rf "$temp_dir"
        return 1
    fi

    # Extraer
    if ! tar -xzf "Image-ExifTool-${target_version}.tar.gz"; then
        cd "$original_dir" 2>/dev/null || cd /
        rm -rf "$temp_dir"
        return 1
    fi

    if ! cd "Image-ExifTool-${target_version}"; then
        cd "$original_dir" 2>/dev/null || cd /
        rm -rf "$temp_dir"
        return 1
    fi

    # Instalar
    if ! perl Makefile.PL &>/dev/null || ! make &>/dev/null || ! sudo make install &>/dev/null; then
        cd "$original_dir" 2>/dev/null || cd /
        rm -rf "$temp_dir"
        return 1
    fi

    # Limpiar
    cd "$original_dir" 2>/dev/null || cd /
    rm -rf "$temp_dir"

    # Verificar instalaciÃ³n
    local new_version=$(exiftool -ver 2>/dev/null || echo "error")
    if [ "$new_version" = "$target_version" ]; then
        echo -e "${GREEN}${CHECK}${NC} ExifTool ${WHITE}${target_version}${NC} $(msg INSTALLED_FROM_SOURCE)"
        return 0
    else
        echo -e "${RED}${CROSS}${NC} $(msg POST_INSTALL_ERROR)"
        return 1
    fi
}

check_and_update_dependencies() {
    # Verificar si debemos chequear actualizaciones (cachÃ© de 24h)
    if ! should_check_updates; then
        return 0
    fi

    local needs_update=false
    local exiftool_version=$(exiftool -ver 2>/dev/null || echo "0")
    local ffmpeg_version=$(ffmpeg -version 2>&1 | head -n1 | grep -oP 'version n?\K[0-9]+\.[0-9]+' | head -1 || echo "0")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # EXIFTOOL - Hybrid system (source first, package manager fallback)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    echo -e "${GRAY}$(msg VERIFYING_EXIFTOOL)${NC}"
    local latest_exiftool=$(get_latest_exiftool_version)

    if ! compare_versions "$exiftool_version" "$latest_exiftool"; then
        echo -e "${YELLOW}âš ${NC}  $(msg EXIFTOOL_OUTDATED) ${WHITE}${exiftool_version}${NC} â†’ ${CYAN}${latest_exiftool}${NC}"

        # Intentar instalar desde fuente (garantiza Ãºltima versiÃ³n)
        if install_exiftool_from_source "$latest_exiftool"; then
            needs_update=true
        else
            # Fallback: try with system package manager
            echo -e "${YELLOW}âš ${NC}  $(msg TRYING_SYSTEM_REPOS)"
            if install_package "exiftool"; then
                local new_version=$(exiftool -ver 2>/dev/null)
                echo -e "${GREEN}${CHECK}${NC} ExifTool $(msg UPDATED_TO) ${WHITE}${new_version}${NC} $(msg FROM_REPOS)"
                needs_update=true
            else
                echo -e "${RED}${CROSS}${NC} $(msg UPDATE_ERROR) ExifTool. $(msg CONTINUING_CURRENT)"
            fi
        fi
        echo ""
    else
        echo -e "${GREEN}${CHECK}${NC} ExifTool ${WHITE}${exiftool_version}${NC} $(msg EXIFTOOL_UPDATED)"
    fi

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FFMPEG - Solo verificar instalaciÃ³n (cada distro tiene su versiÃ³n vÃ¡lida)
    # Nota: No comparamos versiones porque compilar ffmpeg es muy lento
    # y cada distribuciÃ³n tiene su propia versiÃ³n optimizada en repos
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    echo -e "${GRAY}$(msg VERIFYING_FFMPEG)${NC}"
    echo -e "${GREEN}${CHECK}${NC} ffmpeg ${WHITE}${ffmpeg_version}${NC} $(msg FFMPEG_UPDATED)"

    # Actualizar cachÃ©
    update_cache

    if [ "$needs_update" = true ]; then
        echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
        echo ""
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE UI
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print_header() {
    clear
    echo -e "${CYAN}"
    cat << "EOF"

   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—
  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘
  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘
  â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•

EOF
    echo -e "${NC}"
    echo -e "${GRAY}        $(msg HEADER_SUBTITLE)${NC}"
    echo -e "${GRAY}        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

print_separator() {
    echo -e "${GRAY}$(msg SEPARATOR)${NC}"
}

print_box() {
    local color="$1"
    local title="$2"
    local content="$3"

    echo -e "${color}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${NC}"
    echo -e "${color}â”‚${NC} ${STYLE_BOLD}${title}${NC}"
    echo -e "${color}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
    echo -e "${content}" | while IFS= read -r line; do
        echo -e "${color}â”‚${NC} ${line}"
    done
    echo -e "${color}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}"
}

spinner() {
    local pid=$1
    local message=$2
    local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '

    tput civis # Ocultar cursor
    while kill -0 "$pid" 2>/dev/null; do
        local temp=${spinstr#?}
        printf "\r${CYAN}%s${NC} %s" "${spinstr:0:1}" "$message"
        spinstr=$temp${spinstr%"$temp"}
        sleep 0.1
    done
    tput cnorm # Mostrar cursor
    printf "\r${CHECK} %s\n" "$message"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE DETECCIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

detect_file_type() {
    local file="$1"
    local mimetype
    local filename=$(basename "$file")

    # Usar cache de MIME types para mejor rendimiento (v2.3)
    mimetype=$(cached_mime_type "$file")

    local type_icon=""
    case "$mimetype" in
        video/*|audio/*)
            FILE_TYPE="$(msg MULTIMEDIA)"
            IS_MULTIMEDIA=true
            type_icon="$VIDEO_ICON"
            ;;
        image/svg+xml)
            FILE_TYPE="$(msg SVG_FILE)"
            IS_MULTIMEDIA=false
            type_icon="$SVG_ICON"
            ;;
        image/*)
            FILE_TYPE="$(msg IMAGE)"
            IS_MULTIMEDIA=false
            type_icon="$IMAGE_ICON"
            ;;
        text/css)
            FILE_TYPE="$(msg CSS_FILE)"
            IS_MULTIMEDIA=false
            type_icon="$CODE_ICON"
            ;;
        application/pdf)
            FILE_TYPE="$(msg PDF)"
            IS_MULTIMEDIA=false
            type_icon="$PDF_ICON"
            ;;
        application/vnd.openxmlformats-officedocument.*|application/vnd.oasis.opendocument.*)
            FILE_TYPE="$(msg OFFICE_DOC)"
            IS_MULTIMEDIA=false
            type_icon="$OFFICE_ICON"
            ;;
        application/msword|application/vnd.ms-*)
            FILE_TYPE="$(msg OFFICE_DOC)"
            IS_MULTIMEDIA=false
            type_icon="$OFFICE_ICON"
            ;;
        application/epub+zip)
            FILE_TYPE="$(msg EPUB_FILE)"
            IS_MULTIMEDIA=false
            EPUB_MODE=true
            type_icon="ğŸ“š"
            ;;
        application/x-bittorrent)
            FILE_TYPE="$(msg TORRENT_FILE)"
            IS_MULTIMEDIA=false
            TORRENT_MODE=true
            type_icon="ğŸ§²"
            ;;
        application/zip|application/x-7z-compressed|application/x-rar*|application/vnd.rar)
            FILE_TYPE="archive"
            IS_MULTIMEDIA=false
            ARCHIVE_MODE=true
            type_icon="$ARCHIVE_ICON"
            ;;
        application/x-tar|application/gzip|application/x-bzip2|application/x-xz)
            # Verificar si es tar comprimido
            if [[ "$filename" =~ \.(tar|tar\.gz|tgz|tar\.bz2|tbz2|tbz|tar\.xz|txz)$ ]]; then
                FILE_TYPE="archive"
                IS_MULTIMEDIA=false
                ARCHIVE_MODE=true
                type_icon="$ARCHIVE_ICON"
            else
                FILE_TYPE="$(msg UNKNOWN)"
                IS_MULTIMEDIA=false
                type_icon="$BULLET"
            fi
            ;;
        *)
            # Fallback: detectar por extensiÃ³n
            local ext="${filename##*.}"
            ext=$(echo "$ext" | tr '[:upper:]' '[:lower:]')
            case "$ext" in
                epub)
                    FILE_TYPE="$(msg EPUB_FILE)"
                    IS_MULTIMEDIA=false
                    EPUB_MODE=true
                    type_icon="ğŸ“š"
                    ;;
                zip|7z|rar|tar|tgz|tbz|tbz2|txz)
                    FILE_TYPE="archive"
                    IS_MULTIMEDIA=false
                    ARCHIVE_MODE=true
                    type_icon="$ARCHIVE_ICON"
                    ;;
                svg)
                    FILE_TYPE="$(msg SVG_FILE)"
                    IS_MULTIMEDIA=false
                    type_icon="$SVG_ICON"
                    ;;
                css)
                    FILE_TYPE="$(msg CSS_FILE)"
                    IS_MULTIMEDIA=false
                    type_icon="$CODE_ICON"
                    ;;
                torrent)
                    FILE_TYPE="$(msg TORRENT_FILE)"
                    IS_MULTIMEDIA=false
                    TORRENT_MODE=true
                    type_icon="ğŸ§²"
                    ;;
                *)
                    FILE_TYPE="$(msg UNKNOWN)"
                    IS_MULTIMEDIA=false
                    type_icon="$BULLET"
                    ;;
            esac
            ;;
    esac

    # Skip output in lightweight mode
    if [ "$LIGHTWEIGHT_MODE" = true ]; then
        return 0
    fi

    echo -e "  ${type_icon} $(msg TYPE_DETECTED): ${YELLOW}${FILE_TYPE}${NC} ${GRAY}(${mimetype})${NC}"
    if [ "$EPUB_MODE" = true ]; then
        echo -e "  ${TOOL_ICON} $(msg PROCESSING): ${CYAN}EPUB Handler${NC}"
    elif [ "$TORRENT_MODE" = true ]; then
        echo -e "  ${TOOL_ICON} $(msg PROCESSING): ${CYAN}Torrent Handler (${TORRENT_CLEAN_MODE})${NC}"
    elif [ "$ARCHIVE_MODE" = true ]; then
        echo -e "  ${TOOL_ICON} $(msg PROCESSING): ${CYAN}Archive Handler${NC}"
    elif [ "$FILE_TYPE" = "$(msg CSS_FILE)" ]; then
        echo -e "  ${TOOL_ICON} $(msg PROCESSING): ${CYAN}Perl (comment removal)${NC}"
    elif [ "$FILE_TYPE" = "$(msg SVG_FILE)" ]; then
        echo -e "  ${TOOL_ICON} $(msg PROCESSING): ${CYAN}Perl (XML cleaning)${NC}"
    else
        echo -e "  ${TOOL_ICON} $(msg PROCESSING): ${CYAN}$([ "$IS_MULTIMEDIA" = true ] && msg EXIFTOOL_FFMPEG || msg EXIFTOOL_ONLY)${NC}"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE ANÃLISIS DE METADATOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_metadata() {
    local file="$1"
    local title="$2"
    local color="$3"

    # Obtener TODOS los metadatos con exiftool (sin filtrar)
    local metadata
    metadata=$(exiftool "$file" 2>/dev/null)

    # Analizar riesgos si el mÃ³dulo estÃ¡ cargado (v2.5)
    if declare -f danger_analyze_metadata &>/dev/null && [ "$LIGHTWEIGHT_MODE" != "true" ]; then
        danger_analyze_metadata "$metadata"
        # Mostrar panel de resumen de riesgos
        danger_show_summary_panel
    fi

    echo ""
    echo -e "${color}${SEARCH_ICON} ${STYLE_BOLD}${title}${NC}"
    echo ""

    if [ -z "$metadata" ] || [ "$(echo "$metadata" | wc -l)" -le 1 ]; then
        echo -e "${GREEN}  ${CHECK} $(msg NO_METADATA_FOUND)${NC}"
        return
    fi

    # Campos bÃ¡sicos del sistema en gris (menos importantes visualmente)
    local system_patterns="ExifTool|File Name|Directory|File Size|File Permissions|File Inode|File Access Date"

    # Valores genÃ©ricos de Handler que NO son sensibles (estructura MP4 estÃ¡ndar)
    local generic_handler_values="VideoHandler|SoundHandler|DataHandler|SubtitleHandler|TextHandler|MetaHandler"

    local line_count=0
    local metadata_found=false

    # Mostrar TODOS los metadatos sin filtrar
    while IFS= read -r line; do
        # Saltar lÃ­neas vacÃ­as
        [ -z "$line" ] && continue

        # Verificar que la lÃ­nea tiene el formato "Key : Value"
        if echo "$line" | grep -q ":"; then
            metadata_found=true
            line_count=$((line_count + 1))

            local key=$(echo "$line" | cut -d: -f1 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
            local value=$(echo "$line" | cut -d: -f2- | sed 's/^[[:space:]]*//')

            # Verificar si danger_detector estÃ¡ disponible y tiene riesgo
            local risk_level="none"
            if declare -f danger_get_field_risk &>/dev/null; then
                risk_level=$(danger_get_field_risk "$key")
            fi

            # Mostrar con formato de riesgo si aplica (v2.5)
            if [[ "$risk_level" != "none" ]] && declare -f danger_highlight_line &>/dev/null; then
                danger_highlight_line "$key" "${key}: ${value}"
            # Fallback al formato original
            elif echo "$key" | grep -qi "Handler" && echo "$value" | grep -qE "(${generic_handler_values})"; then
                echo -e "  ${BLUE}â—${NC} ${CYAN}${key}:${NC} ${value}"
            elif echo "$key" | grep -qE "(${system_patterns})"; then
                echo -e "  ${GRAY}â—${NC} ${GRAY}${key}:${NC} ${GRAY}${value}${NC}"
            else
                echo -e "  ${BLUE}â—${NC} ${CYAN}${key}:${NC} ${value}"
            fi
        fi
    done <<< "$metadata"

    if [ "$metadata_found" = false ]; then
        echo -e "${GREEN}  ${CHECK} $(msg NO_METADATA_FOUND)${NC}"
    else
        echo ""
        echo -e "${GRAY}  $(msg METADATA_FIELDS_TOTAL) ${WHITE}${line_count}${NC}"
    fi

    echo ""
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PERFORMANCE OPTIMIZATIONS (v2.3)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cached_mime_type() {
    local file="$1"
    local abs_path

    # Obtener ruta absoluta para usar como clave
    abs_path=$(readlink -f "$file" 2>/dev/null || echo "$file")

    # Verificar si estÃ¡ en cache
    if [[ -n "${MIME_CACHE[$abs_path]:-}" ]]; then
        echo "${MIME_CACHE[$abs_path]}"
        return 0
    fi

    # Obtener MIME type y cachear
    local mime
    mime=$(file -b --mime-type "$file" 2>/dev/null)
    MIME_CACHE[$abs_path]="$mime"

    echo "$mime"
}

clear_mime_cache() {
    MIME_CACHE=()
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE LIGHTWEIGHT MODE (v2.3)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

count_metadata_fields() {
    local file="$1"
    local count=0

    # Contar campos de metadatos excluyendo los del sistema
    count=$(exiftool "$file" 2>/dev/null | \
        grep -vE "ExifTool|File Name|Directory|File Size|File Permissions|File Inode|File Access Date|File Modification" | \
        grep -c ":" 2>/dev/null || echo "0")

    echo "$count"
}

lightweight_output() {
    local input="$1"
    local output="$2"
    local fields_before="$3"
    local fields_after="$4"
    local status="${5:-success}"

    local removed=$((fields_before - fields_after))
    local input_basename=$(basename "$input")
    local output_basename=$(basename "$output")

    if [ "$status" = "success" ]; then
        if [ "$LANG_CODE" = "es" ]; then
            echo "${input_basename} -> ${output_basename} (${removed} campos eliminados)"
        else
            echo "${input_basename} -> ${output_basename} (${removed} fields removed)"
        fi
    else
        if [ "$LANG_CODE" = "es" ]; then
            echo "${input_basename} -> ERROR: ${output}"
        else
            echo "${input_basename} -> ERROR: ${output}"
        fi
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE HASH Y VERIFICACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

calculate_hash() {
    local file="$1"
    sha256sum "$file" 2>/dev/null | cut -d' ' -f1
}

detect_duplicate() {
    local file="$1"

    # Obtener metadatos
    local metadata
    metadata=$(exiftool "$file" 2>/dev/null)

    if [ -z "$metadata" ]; then
        return 1  # No se pudo leer, no es duplicado
    fi

    # Contar metadatos sensibles (excluyendo metadatos bÃ¡sicos del archivo)
    local sensitive_count
    sensitive_count=$(echo "$metadata" | grep -vE "ExifTool|File Name|Directory|File Size|File Permissions|File Inode|File Access Date|File Modification" | grep -c ":" || echo "0")

    # Si hay menos de 3 campos de metadatos (muy pocos), probablemente ya estÃ¡ limpio
    if [ "$sensitive_count" -lt 3 ]; then
        return 0  # Es un posible duplicado/ya limpio
    fi

    return 1  # No es duplicado
}

verify_hashes() {
    local original_file="$1"
    local clean_file="$2"

    echo ""
    print_separator
    echo -e "${STYLE_BOLD}${CYAN}$(msg HASH_VERIFICATION)${NC}"
    print_separator
    echo ""

    local hash_original=$(calculate_hash "$original_file")
    local hash_clean=$(calculate_hash "$clean_file")

    echo -e "  ${CYAN}â—${NC} $(msg HASH_ORIGINAL)"
    echo -e "    ${GRAY}${hash_original}${NC}"
    echo ""
    echo -e "  ${CYAN}â—${NC} $(msg HASH_CLEAN)"
    echo -e "    ${GRAY}${hash_clean}${NC}"
    echo ""

    if [ "$hash_original" != "$hash_clean" ]; then
        echo -e "${GREEN}${CHECK}${NC} $(msg HASH_DIFFERENT)"
    else
        echo -e "${YELLOW}${WARN}${NC} $(msg HASH_IDENTICAL)"
    fi
    echo ""
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE LIMPIEZA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SVG: Clean SVG metadata (ExifTool can't write SVG files)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

clean_svg() {
    local input="$1"
    local output="$2"

    echo -e "${ARROW} $(msg CLEANING_WITH_EXIFTOOL) ${CYAN}Perl (XML)${NC}..."

    # SVG cleaning: remove metadata element, XML comments, and RDF data
    perl -0777 -pe '
        # Remove <metadata>...</metadata> block
        s|<metadata[^>]*>.*?</metadata>||gsi;
        # Remove XML comments <!-- ... -->
        s|<!--.*?-->||gs;
        # Remove rdf:RDF blocks that might be outside metadata
        s|<rdf:RDF[^>]*>.*?</rdf:RDF>||gsi;
    ' "$input" > "$output" &
    spinner $! "$(msg REMOVING_METADATA_EXIFTOOL)"

    echo -e "${GREEN}${CHECK}${NC} $(msg METADATA_REMOVED)"

    return 0
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CSS: Show and clean CSS comments (metadata equivalent)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

show_css_metadata() {
    local file="$1"
    local title="$2"
    local color="$3"

    echo ""
    echo -e "${color}${SEARCH_ICON} ${STYLE_BOLD}${title}${NC}"
    echo ""

    # Extraer comentarios CSS /* ... */
    local comments
    comments=$(perl -0777 -ne 'print "$1\n" while m{(/\*.*?\*/)}gs' "$file" 2>/dev/null)

    if [ -z "$comments" ]; then
        echo -e "${GREEN}  ${CHECK} $(msg CSS_NO_COMMENTS)${NC}"
        return
    fi

    local comment_count
    comment_count=$(echo "$comments" | grep -c '/\*') || comment_count=0

    echo -e "${STYLE_BOLD}  $(msg CSS_COMMENTS_FOUND): ${WHITE}${comment_count}${NC}"
    echo ""

    # Mostrar hasta 10 comentarios (truncados si son largos)
    local shown=0
    while IFS= read -r comment; do
        [[ -z "$comment" ]] && continue
        ((shown++)) || true
        [[ $shown -gt 10 ]] && break

        # Truncar comentarios largos
        if [[ ${#comment} -gt 80 ]]; then
            comment="${comment:0:77}..."
        fi

        # Colorear segÃºn contenido sensible
        if echo "$comment" | grep -qiE "(author|copyright|version|created|license|company|email)"; then
            echo -e "  ${RED}â—${NC} ${RED}${comment}${NC}"
        else
            echo -e "  ${YELLOW}â—${NC} ${GRAY}${comment}${NC}"
        fi
    done <<< "$comments" || true

    if [ $comment_count -gt 10 ]; then
        echo -e "  ${GRAY}... and $((comment_count - 10)) more comments${NC}"
    fi

    echo ""
}

clean_css() {
    local input="$1"
    local output="$2"

    echo -e "${ARROW} $(msg CLEANING_CSS) ${CYAN}Perl${NC}..."

    # Eliminar todos los comentarios CSS /* ... */ preservando el resto
    perl -0777 -pe 's|/\*.*?\*/||gs' "$input" > "$output" &
    spinner $! "$(msg CLEANING_CSS)"

    # Verificar resultado
    local remaining=$(perl -0777 -ne 'print "$1\n" while m{(/\*.*?\*/)}gs' "$output" 2>/dev/null | wc -l)

    if [ "$remaining" -eq 0 ]; then
        echo -e "${GREEN}${CHECK}${NC} $(msg CSS_COMMENTS_REMOVED)"
    fi

    return 0
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

clean_with_exiftool() {
    local input="$1"
    local output="$2"

    echo -e "${ARROW} $(msg CLEANING_WITH_EXIFTOOL) ${CYAN}ExifTool${NC}..."

    # Copiar archivo para preservar el original
    cp "$input" "$output"

    # Limpiar metadatos
    exiftool -all= -overwrite_original "$output" &>/dev/null &
    spinner $! "$(msg REMOVING_METADATA_EXIFTOOL)"

    return 0
}

clean_with_ffmpeg() {
    local input="$1"
    local output="$2"

    echo -e "${ARROW} $(msg DEEP_CLEAN_WITH_FFMPEG) ${CYAN}ffmpeg${NC}..."

    # Detectar si es audio o video
    local codec_copy="-c copy"

    # Limpiar metadatos del contenedor
    ffmpeg -i "$input" -map_metadata -1 -fflags +bitexact $codec_copy "$output" -y &>/dev/null &
    spinner $! "$(msg REMOVING_CONTAINER_METADATA)"

    return 0
}

perform_cleaning() {
    local input="$1"
    local output="$2"

    echo ""
    print_separator
    echo -e "${STYLE_BOLD}${MAGENTA}$(msg STARTING_DEEP_CLEAN)${NC}"
    print_separator
    echo ""

    if [ "$IS_MULTIMEDIA" = true ]; then
        # Check if re-encoding mode is enabled
        if [ "$REENCODE_MODE" = true ]; then
            # Re-encoding mode: full transcoding with metadata removal
            local script_dir="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
            local lib_dir="${script_dir}/lib"

            if [ ! -f "${lib_dir}/reencode_handler.sh" ]; then
                echo -e "${RED}${CROSS} Error: Re-encode handler not found in ${lib_dir}${NC}" >&2
                return 1
            fi

            # Export necessary variables
            export RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY STYLE_BOLD NC
            export CHECK CROSS ARROW BULLET WARN INFO CLEAN SHIELD FILE_ICON SIZE_ICON
            export SPARKLES SEARCH_ICON TOOL_ICON
            export LANG_CODE
            export REENCODE_PRESET REENCODE_CRF REENCODE_VIDEO_CODEC REENCODE_AUDIO_CODEC
            export REENCODE_CONTAINER REENCODE_HW_ACCEL

            # Export msg function
            export -f msg

            # Load re-encode handler
            source "${lib_dir}/reencode_handler.sh"

            # Set confirmation based on CLI flag
            if [ "$REENCODE_NO_CONFIRM" = true ]; then
                REENCODE_CONFIRM=false
            fi

            # Execute re-encoding
            reencode_main "$input" "$output"
            return $?
        else
            # Standard mode: stream copy (no re-encoding)
            local temp_ffmpeg="${TEMP_DIR}/temp_ffmpeg_$(basename "$input")"

            clean_with_ffmpeg "$input" "$temp_ffmpeg"
            clean_with_exiftool "$temp_ffmpeg" "$output"

            rm -f "$temp_ffmpeg"
        fi
    elif [ "$FILE_TYPE" = "$(msg CSS_FILE)" ]; then
        # Para CSS: eliminar comentarios con perl
        clean_css "$input" "$output"
    elif [ "$FILE_TYPE" = "$(msg SVG_FILE)" ]; then
        # Para SVG: usar perl XML cleaning (ExifTool no puede escribir SVG)
        clean_svg "$input" "$output"
    else
        # Para otros archivos: solo exiftool
        clean_with_exiftool "$input" "$output"
    fi

    # Deep cleaning (v2.6) - after standard metadata cleaning
    if [ "$DEEP_CLEAN_ENABLED" = true ]; then
        if declare -f deep_clean_file &>/dev/null; then
            echo ""
            echo -e "${CYAN}${TOOL_ICON} $(msg DEEP_CLEAN_PROCESSING)${NC}"
            deep_clean_file "$output" "$output"
        fi
    fi

    echo ""
    echo -e "${GREEN}${SPARKLES} ${CHECK} $(msg CLEANING_COMPLETED)${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE COMPARACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_file_info() {
    local file="$1"
    local size
    local hash

    size=$(du -h "$file" | cut -f1)
    hash=$(sha256sum "$file" | cut -d' ' -f1 | cut -c1-16)

    echo -e "  ${SIZE_ICON} $(msg SIZE): ${CYAN}${size}${NC}"
    echo -e "  ${BULLET} SHA256: ${GRAY}${hash}...${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N PRINCIPAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cleanup() {
    if [ -n "$TEMP_DIR" ] && [ -d "$TEMP_DIR" ]; then
        rm -rf "$TEMP_DIR"
    fi
}

trap cleanup EXIT

main() {
    # Detectar idioma del sistema
    detect_language

    # Detectar sistema y gestor de paquetes
    detect_system

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CARGAR MÃ“DULOS v1.5
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    local script_path="${BASH_SOURCE[0]}"
    if [ -L "$script_path" ]; then
        script_path="$(readlink -f "$script_path")"
    fi
    local lib_dir="$(dirname "$script_path")/lib"

    # Cargar mÃ³dulo de configuraciÃ³n
    if [ -f "${lib_dir}/config_loader.sh" ]; then
        source "${lib_dir}/config_loader.sh"
        config_load
    fi

    # Cargar mÃ³dulo de logging
    if [ -f "${lib_dir}/logger.sh" ]; then
        source "${lib_dir}/logger.sh"
    fi

    # Cargar mÃ³dulo de notificaciones
    if [ -f "${lib_dir}/notifier.sh" ]; then
        source "${lib_dir}/notifier.sh"
    fi

    # Cargar mÃ³dulo de detecciÃ³n de riesgos (v2.5)
    if [ -f "${lib_dir}/danger_detector.sh" ]; then
        source "${lib_dir}/danger_detector.sh"
        danger_init
    fi

    # Cargar mÃ³dulos de limpieza profunda (v2.6)
    if [ -f "${lib_dir}/deep_clean/deep_clean_core.sh" ]; then
        source "${lib_dir}/deep_clean/deep_clean_core.sh"
    fi

    # Cargar mÃ³dulos forenses (v2.6)
    if [ -f "${lib_dir}/forensic/forensic_core.sh" ]; then
        source "${lib_dir}/forensic/forensic_core.sh"
    fi

    # Parsear argumentos
    local file_arg=""
    local output_arg=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --batch)
                BATCH_MODE=true
                shift
                ;;
            --jobs|-j)
                BATCH_JOBS="$2"
                shift 2
                ;;
            --pattern)
                BATCH_PATTERNS+=("$2")
                shift 2
                ;;
            --recursive|-r)
                BATCH_RECURSIVE=true
                shift
                ;;
            --confirm)
                BATCH_CONFIRM=true
                shift
                ;;
            --no-confirm)
                BATCH_CONFIRM=false
                shift
                ;;
            --verbose|-v)
                BATCH_VERBOSE=true
                shift
                ;;
            --quiet|-q)
                BATCH_QUIET=true
                shift
                ;;
            --verify)
                VERIFY_HASH=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --no-duplicate-check)
                CHECK_DUPLICATES=false
                shift
                ;;
            --interactive|-i)
                INTERACTIVE_MODE=true
                shift
                ;;
            --archive-password)
                ARCHIVE_PASSWORD="$2"
                shift 2
                ;;
            --archive-preview)
                ARCHIVE_PREVIEW=true
                shift
                ;;
            --notify)
                NOTIFY_MODE=true
                shift
                ;;
            --show-only)
                SHOW_ONLY=true
                shift
                ;;
            --unknown-policy=*)
                ARCHIVE_UNKNOWN_POLICY="${1#*=}"
                # Validar valor
                case "$ARCHIVE_UNKNOWN_POLICY" in
                    skip|warn|fail|include) ;;
                    *)
                        echo -e "${RED}${CROSS} Invalid --unknown-policy value: $ARCHIVE_UNKNOWN_POLICY${NC}" >&2
                        echo -e "Valid values: skip, warn, fail, include"
                        exit 1
                        ;;
                esac
                shift
                ;;
            --unknown-policy)
                ARCHIVE_UNKNOWN_POLICY="$2"
                # Validar valor
                case "$ARCHIVE_UNKNOWN_POLICY" in
                    skip|warn|fail|include) ;;
                    *)
                        echo -e "${RED}${CROSS} Invalid --unknown-policy value: $ARCHIVE_UNKNOWN_POLICY${NC}" >&2
                        echo -e "Valid values: skip, warn, fail, include"
                        exit 1
                        ;;
                esac
                shift 2
                ;;
            --torrent-mode=*)
                TORRENT_CLEAN_MODE="${1#*=}"
                # Validar valor
                case "$TORRENT_CLEAN_MODE" in
                    safe|aggressive) ;;
                    *)
                        echo -e "${RED}${CROSS} Invalid --torrent-mode value: $TORRENT_CLEAN_MODE${NC}" >&2
                        echo -e "Valid values: safe, aggressive"
                        exit 1
                        ;;
                esac
                shift
                ;;
            --torrent-mode)
                TORRENT_CLEAN_MODE="$2"
                # Validar valor
                case "$TORRENT_CLEAN_MODE" in
                    safe|aggressive) ;;
                    *)
                        echo -e "${RED}${CROSS} Invalid --torrent-mode value: $TORRENT_CLEAN_MODE${NC}" >&2
                        echo -e "Valid values: safe, aggressive"
                        exit 1
                        ;;
                esac
                shift 2
                ;;
            --lightweight|-l)
                LIGHTWEIGHT_MODE=true
                shift
                ;;
            # Re-encoding options (v2.4)
            --reencode)
                REENCODE_MODE=true
                shift
                ;;
            --reencode=*)
                REENCODE_MODE=true
                REENCODE_PRESET="${1#*=}"
                # Validate preset
                case "$REENCODE_PRESET" in
                    high|medium|low) ;;
                    *)
                        echo -e "${RED}${CROSS} Invalid --reencode preset: $REENCODE_PRESET${NC}" >&2
                        echo -e "Valid values: high, medium, low"
                        exit 1
                        ;;
                esac
                shift
                ;;
            --reencode-crf=*)
                REENCODE_CRF="${1#*=}"
                # Validate CRF (0-63)
                if ! [[ "$REENCODE_CRF" =~ ^[0-9]+$ ]] || [ "$REENCODE_CRF" -gt 63 ]; then
                    echo -e "${RED}${CROSS} Invalid --reencode-crf value: $REENCODE_CRF${NC}" >&2
                    echo -e "Valid values: 0-63"
                    exit 1
                fi
                shift
                ;;
            --video-codec=*)
                REENCODE_VIDEO_CODEC="${1#*=}"
                # Validate codec
                case "$REENCODE_VIDEO_CODEC" in
                    h264|x264|libx264|h265|x265|libx265|hevc|av1|libsvtav1|svtav1) ;;
                    *)
                        echo -e "${RED}${CROSS} Invalid --video-codec value: $REENCODE_VIDEO_CODEC${NC}" >&2
                        echo -e "Valid values: h264, h265, av1"
                        exit 1
                        ;;
                esac
                shift
                ;;
            --audio-codec=*)
                REENCODE_AUDIO_CODEC="${1#*=}"
                # Validate codec
                case "$REENCODE_AUDIO_CODEC" in
                    aac|opus|libopus|flac) ;;
                    *)
                        echo -e "${RED}${CROSS} Invalid --audio-codec value: $REENCODE_AUDIO_CODEC${NC}" >&2
                        echo -e "Valid values: aac, opus, flac"
                        exit 1
                        ;;
                esac
                shift
                ;;
            --container=*)
                REENCODE_CONTAINER="${1#*=}"
                # Validate container
                case "$REENCODE_CONTAINER" in
                    mp4|mkv|webm) ;;
                    *)
                        echo -e "${RED}${CROSS} Invalid --container value: $REENCODE_CONTAINER${NC}" >&2
                        echo -e "Valid values: mp4, mkv, webm"
                        exit 1
                        ;;
                esac
                shift
                ;;
            --hw-accel=*)
                REENCODE_HW_ACCEL="${1#*=}"
                # Validate hw accel
                case "$REENCODE_HW_ACCEL" in
                    auto|nvidia|amd|intel|cpu) ;;
                    *)
                        echo -e "${RED}${CROSS} Invalid --hw-accel value: $REENCODE_HW_ACCEL${NC}" >&2
                        echo -e "Valid values: auto, nvidia, amd, intel, cpu"
                        exit 1
                        ;;
                esac
                shift
                ;;
            --reencode-no-confirm)
                REENCODE_NO_CONFIRM=true
                shift
                ;;
            # Deep Clean options (v2.6)
            --deep-clean)
                DEEP_CLEAN_ENABLED=true
                shift
                ;;
            # Forensic options (v2.6)
            --forensic-report)
                FORENSIC_REPORT_ENABLED=true
                shift
                ;;
            --forensic-report=*)
                FORENSIC_REPORT_ENABLED=true
                FORENSIC_REPORT_FORMAT="${1#*=}"
                case "$FORENSIC_REPORT_FORMAT" in
                    json|dfxml|all) ;;
                    *)
                        echo -e "${RED}${CROSS} Invalid --forensic-report format: $FORENSIC_REPORT_FORMAT${NC}" >&2
                        echo -e "Valid values: json, dfxml, all"
                        exit 1
                        ;;
                esac
                shift
                ;;
            --multihash)
                FORENSIC_MULTIHASH=true
                shift
                ;;
            --case-id=*)
                FORENSIC_CASE_ID="${1#*=}"
                shift
                ;;
            --evidence-id=*)
                FORENSIC_EVIDENCE_ID="${1#*=}"
                shift
                ;;
            --operator=*)
                FORENSIC_OPERATOR="${1#*=}"
                shift
                ;;
            -h|--help)
                print_header
                echo -e "${STYLE_BOLD}$(msg USAGE)${NC}"
                echo -e "  $0 [$(msg OPTIONS)] <file> [output_file]"
                echo -e "  $0 --batch --pattern PATTERN [$(msg OPTIONS)] [directory]"
                echo ""
                echo -e "${STYLE_BOLD}$(msg OPTIONS)${NC}"
                echo -e "  ${CYAN}--verify${NC}              $(msg HASH_VERIFICATION | tr '[:upper:]' '[:lower:]')"
                echo -e "  ${CYAN}--dry-run${NC}             $(msg DRY_RUN_NOTICE | tr '[:upper:]' '[:lower:]')"
                echo -e "  ${CYAN}--show-only${NC}           Display metadata without cleaning"
                echo -e "  ${CYAN}--no-duplicate-check${NC}  Skip duplicate detection"
                echo -e "  ${CYAN}--interactive, -i${NC}     Launch interactive TUI mode"
                echo -e "  ${CYAN}--archive-password${NC}    Password for encrypted archives"
                echo -e "  ${CYAN}--archive-preview${NC}     Preview archive contents without processing"
                echo -e "  ${CYAN}--unknown-policy${NC}      Policy for unknown files in archives:"
                echo -e "                          skip (default), warn, fail, include"
                echo -e "  ${CYAN}--torrent-mode${NC}        Torrent cleaning mode:"
                echo -e "                          safe (default) - preserves functionality"
                echo -e "                          aggressive - maximum privacy"
                echo -e "  ${CYAN}--lightweight, -l${NC}     Minimal output (one line per file)"
                echo -e "  ${CYAN}--notify${NC}              Send desktop notification on completion"
                echo -e "  ${CYAN}-h, --help${NC}            Show this help"
                echo ""
                echo -e "${STYLE_BOLD}Re-encoding Mode (v2.4):${NC}"
                echo -e "  ${CYAN}--reencode${NC}            Re-encode multimedia (uses medium preset)"
                echo -e "  ${CYAN}--reencode=PRESET${NC}     Re-encode with quality preset (high/medium/low)"
                echo -e "  ${CYAN}--reencode-crf=N${NC}      Custom CRF value (0-63, lower=better)"
                echo -e "  ${CYAN}--video-codec=CODEC${NC}   Video codec: h264, h265, av1"
                echo -e "  ${CYAN}--audio-codec=CODEC${NC}   Audio codec: aac, opus, flac"
                echo -e "  ${CYAN}--container=FORMAT${NC}    Output format: mp4, mkv, webm"
                echo -e "  ${CYAN}--hw-accel=TYPE${NC}       Hardware acceleration:"
                echo -e "                          auto (default), nvidia, amd, intel, cpu"
                echo -e "  ${CYAN}--reencode-no-confirm${NC} Skip confirmation prompt"
                echo ""
                echo -e "${STYLE_BOLD}Deep Clean Mode (v2.6):${NC}"
                echo -e "  ${CYAN}--deep-clean${NC}          Enable enhanced cleaning:"
                echo -e "                          - Remove embedded thumbnails (IFD1)"
                echo -e "                          - Linearize PDFs (remove incremental updates)"
                echo -e "                          - Remove hidden video streams"
                echo ""
                echo -e "${STYLE_BOLD}Forensic Reporting (v2.6):${NC}"
                echo -e "  ${CYAN}--forensic-report${NC}     Generate forensic report (JSON format)"
                echo -e "  ${CYAN}--forensic-report=FMT${NC} Report format: json, dfxml, all"
                echo -e "  ${CYAN}--multihash${NC}           Calculate MD5, SHA1, SHA256 hashes"
                echo -e "  ${CYAN}--case-id=ID${NC}          Case identifier for chain of custody"
                echo -e "  ${CYAN}--evidence-id=ID${NC}      Evidence identifier"
                echo -e "  ${CYAN}--operator=NAME${NC}       Operator name for reports"
                echo ""
                echo -e "${STYLE_BOLD}$(msg BATCH_MODE):${NC}"
                echo -e "  ${CYAN}--batch${NC}               Enable batch processing"
                echo -e "  ${CYAN}--pattern PATTERN${NC}     File pattern (can repeat, e.g., '*.jpg')"
                echo -e "  ${CYAN}--jobs N, -j N${NC}       Parallel jobs (default: auto-detect)"
                echo -e "  ${CYAN}--recursive, -r${NC}      Recursive directory search"
                echo -e "  ${CYAN}--confirm${NC}            Interactive file selection (default)"
                echo -e "  ${CYAN}--no-confirm${NC}         Skip confirmation (for automation)"
                echo -e "  ${CYAN}--verbose, -v${NC}        Verbose output"
                echo -e "  ${CYAN}--quiet, -q${NC}          Minimal output"
                echo ""
                echo -e "${STYLE_BOLD}$(msg EXAMPLES)${NC}"
                echo -e "  ${GRAY}# Single file mode${NC}"
                echo -e "  $0 documento.pdf"
                echo -e "  $0 video.mp4 video_clean.mp4"
                echo -e "  $0 imagen.jpg --verify"
                echo -e "  $0 foto.png --dry-run"
                echo ""
                echo -e "  ${GRAY}# Batch mode${NC}"
                echo -e "  $0 --batch --pattern '*.jpg' ~/Photos"
                echo -e "  $0 --batch --pattern '*.jpg' --pattern '*.png' ."
                echo -e "  $0 --batch -r -j 8 --pattern '*.pdf' ~/Documents"
                echo -e "  $0 --batch --no-confirm --pattern '*.mp4' /media/videos"
                echo ""
                echo -e "  ${GRAY}# Interactive mode${NC}"
                echo -e "  $0 --interactive"
                echo -e "  $0 -i"
                echo ""
                echo -e "  ${GRAY}# Archive mode (v1.4)${NC}"
                echo -e "  $0 photos.zip"
                echo -e "  $0 documents.7z --archive-preview"
                echo -e "  $0 secret.rar --archive-password 'mypass'"
                echo -e "  $0 data.zip --unknown-policy=warn"
                echo ""
                echo -e "  ${GRAY}# EPUB ebook mode (v2.2)${NC}"
                echo -e "  $0 book.epub"
                echo -e "  $0 novel.epub --show-only"
                echo ""
                echo -e "  ${GRAY}# Torrent mode (v2.3)${NC}"
                echo -e "  $0 file.torrent"
                echo -e "  $0 file.torrent --torrent-mode=aggressive"
                echo -e "  $0 file.torrent --show-only"
                echo ""
                echo -e "  ${GRAY}# Lightweight mode (v2.3)${NC}"
                echo -e "  $0 photo.jpg --lightweight"
                echo -e "  $0 --batch --pattern '*.jpg' --lightweight ."
                echo ""
                echo -e "  ${GRAY}# Re-encoding mode (v2.4)${NC}"
                echo -e "  $0 video.mp4 --reencode"
                echo -e "  $0 video.mp4 --reencode=high"
                echo -e "  $0 video.mp4 --reencode --video-codec=h265 --audio-codec=opus"
                echo -e "  $0 video.mkv --reencode --container=mp4"
                echo -e "  $0 video.mp4 --reencode --reencode-crf=20"
                echo -e "  $0 video.mp4 --reencode --hw-accel=cpu"
                echo ""
                exit 0
                ;;
            -*)
                echo -e "${RED}${CROSS} Unknown option: $1${NC}\n"
                echo -e "Use ${CYAN}--help${NC} for usage information"
                exit 1
                ;;
            *)
                if [ -z "$file_arg" ]; then
                    file_arg="$1"
                elif [ -z "$output_arg" ]; then
                    output_arg="$1"
                fi
                shift
                ;;
        esac
    done

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INICIALIZAR MÃ“DULOS v1.5
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Aplicar configuraciÃ³n a variables globales
    if declare -f config_apply_globals &>/dev/null; then
        config_apply_globals
        # Obtener sufijo de salida de la configuraciÃ³n
        OUTPUT_SUFFIX=$(config_get "OUTPUT_SUFFIX" "_clean")
    fi

    # Inicializar logging
    if declare -f log_init &>/dev/null; then
        log_init
    fi

    # Inicializar notificaciones
    if declare -f notify_init &>/dev/null; then
        if [ "$NOTIFY_MODE" = true ]; then
            NOTIFY_FORCE=true
        fi
        notify_init
    fi

    # Inicializar mÃ³dulo forense (v2.6)
    if [ "$FORENSIC_REPORT_ENABLED" = true ]; then
        if declare -f forensic_init &>/dev/null; then
            forensic_init
        fi
    fi

    # Dispatch a interactive mode si estÃ¡ activado
    if [ "$INTERACTIVE_MODE" = true ]; then
        local script_path="${BASH_SOURCE[0]}"
        # Resolver enlace simbÃ³lico si existe
        if [ -L "$script_path" ]; then
            script_path="$(readlink -f "$script_path")"
        fi
        local script_dir="$(cd "$(dirname "$script_path")" && pwd)"
        local lib_dir="${script_dir}/lib"

        if [ ! -f "${lib_dir}/interactive_mode.sh" ]; then
            echo -e "${RED}${CROSS} Error: Interactive mode libraries not found in ${lib_dir}${NC}" >&2
            exit 1
        fi

        # Exportar variables necesarias para interactive mode
        export RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY STYLE_BOLD NC
        export CHECK CROSS ARROW BULLET WARN INFO CLEAN SHIELD FILE_ICON SIZE_ICON
        export VIDEO_ICON IMAGE_ICON PDF_ICON OFFICE_ICON SPARKLES SEARCH_ICON
        export LOCATION_ICON CAMERA_ICON COMPUTER_ICON CALENDAR_ICON TOOL_ICON
        export ARCHIVE_ICON
        export LANG_CODE

        # Exportar funciones necesarias
        export -f msg
        export -f print_header

        # Cargar y ejecutar interactive mode
        source "${lib_dir}/interactive_mode.sh"
        interactive_main
        exit $?
    fi

    # Dispatch a batch mode si estÃ¡ activado
    if [ "$BATCH_MODE" = true ]; then
        # Determinar directorio lib
        local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        local lib_dir="${script_dir}/lib"

        # Cargar batch_core
        if [ ! -f "${lib_dir}/batch_core.sh" ]; then
            echo -e "${RED}${CROSS} Error: Batch libraries not found in ${lib_dir}${NC}" >&2
            exit 1
        fi

        # Configurar BATCH_LIGHTWEIGHT basado en LIGHTWEIGHT_MODE
        BATCH_LIGHTWEIGHT="$LIGHTWEIGHT_MODE"

        # Exportar variables necesarias para batch
        export BATCH_MODE BATCH_JOBS BATCH_PATTERNS BATCH_RECURSIVE BATCH_CONFIRM BATCH_VERBOSE BATCH_QUIET BATCH_LIGHTWEIGHT
        export RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY STYLE_BOLD NC
        export CHECK CROSS ARROW BULLET WARN INFO CLEAN SHIELD FILE_ICON SIZE_ICON
        export VIDEO_ICON IMAGE_ICON PDF_ICON OFFICE_ICON SPARKLES SEARCH_ICON
        export LOCATION_ICON CAMERA_ICON COMPUTER_ICON CALENDAR_ICON TOOL_ICON
        export LANG_CODE

        # Exportar funciÃ³n msg para que las librerÃ­as puedan usarla
        export -f msg

        # Cargar y ejecutar batch mode
        source "${lib_dir}/batch_core.sh"

        # Ejecutar con el directorio (o usar file_arg como directorio si existe)
        local target_dir="${file_arg:-.}"
        batch_main "$target_dir"
        exit $?
    fi

    # Verificar que se proporcionÃ³ un archivo
    if [ -z "$file_arg" ]; then
        print_header
        echo -e "${RED}${CROSS} $(msg ERROR_NO_FILE)${NC}\n"
        echo -e "${STYLE_BOLD}$(msg USAGE)${NC}"
        echo -e "  $0 [options] <file> [output_file]"
        echo ""
        echo -e "${STYLE_BOLD}$(msg EXAMPLES)${NC}"
        echo -e "  $0 documento.pdf"
        echo -e "  $0 video.mp4 video_clean.mp4"
        echo -e "  $0 imagen.jpg --verify"
        echo ""
        exit 1
    fi

    ORIGINAL_FILE="$file_arg"

    # Verificar que el archivo existe
    if [ ! -f "$ORIGINAL_FILE" ]; then
        print_header
        echo -e "${RED}${CROSS} $(msg ERROR_FILE_NOT_EXISTS "$ORIGINAL_FILE")${NC}\n"
        exit 1
    fi

    # Determinar archivo de salida
    if [ -n "$output_arg" ]; then
        OUTPUT_FILE="$output_arg"
    else
        local basename="${ORIGINAL_FILE%.*}"
        local extension="${ORIGINAL_FILE##*.}"
        OUTPUT_FILE="${basename}${OUTPUT_SUFFIX}.${extension}"
    fi

    # Log inicio de operaciÃ³n
    if declare -f log_operation_start &>/dev/null; then
        log_operation_start "$ORIGINAL_FILE" "$FILE_TYPE"
    fi

    # Crear directorio temporal
    TEMP_DIR=$(mktemp -d)

    # Verificar y actualizar dependencias automÃ¡ticamente
    check_and_update_dependencies

    # Mostrar interfaz (skip en lightweight mode)
    if [ "$LIGHTWEIGHT_MODE" != true ]; then
        print_header

        # Modo DRY-RUN
        if [ "$DRY_RUN" = true ]; then
            echo -e "${YELLOW}${WARN} ${STYLE_BOLD}$(msg DRY_RUN_MODE)${NC}"
            echo -e "${GRAY}$(msg DRY_RUN_NOTICE)${NC}"
            echo ""
        fi

        echo -e "${STYLE_BOLD}${FILE_ICON} $(msg FILE_TO_PROCESS)${NC}"
        echo -e "  ${ARROW} ${WHITE}${ORIGINAL_FILE}${NC}"
        show_file_info "$ORIGINAL_FILE"
        echo ""
    fi

    detect_file_type "$ORIGINAL_FILE"

    # Dispatch a EPUB mode si se detectÃ³ un EPUB
    if [ "$EPUB_MODE" = true ]; then
        local script_dir="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
        local lib_dir="${script_dir}/lib"

        if [ ! -f "${lib_dir}/epub_handler.sh" ]; then
            echo -e "${RED}${CROSS} Error: EPUB handler not found in ${lib_dir}${NC}" >&2
            exit 1
        fi

        # Exportar variables necesarias para EPUB mode
        export RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY STYLE_BOLD NC
        export CHECK CROSS ARROW BULLET WARN INFO CLEAN SHIELD FILE_ICON SIZE_ICON
        export SPARKLES SEARCH_ICON TOOL_ICON
        export LANG_CODE DRY_RUN VERIFY_HASH SHOW_ONLY

        # Exportar funciÃ³n msg
        export -f msg

        # Cargar EPUB handler
        source "${lib_dir}/epub_handler.sh"

        # Modo SHOW-ONLY para EPUB
        if [ "$SHOW_ONLY" = true ]; then
            echo ""
            echo -e "${CYAN}${INFO} ${STYLE_BOLD}$(msg SHOW_ONLY_MODE)${NC}"
            echo -e "${GRAY}$(msg SHOW_ONLY_NOTICE)${NC}"
            epub_show_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$CYAN"
            exit 0
        fi

        # Modo DRY-RUN para EPUB
        if [ "$DRY_RUN" = true ]; then
            echo ""
            epub_show_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$RED"
            echo ""
            echo -e "${CYAN}${INFO} $(msg WOULD_CREATE) ${GREEN}${OUTPUT_FILE}${NC}"
            echo -e "${GRAY}$(msg DRY_RUN_NOTICE)${NC}"
            exit 0
        fi

        # Mostrar metadatos antes
        epub_show_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$RED"

        # Procesar EPUB
        epub_main "$ORIGINAL_FILE" "$OUTPUT_FILE"
        local epub_result=$?

        if [ $epub_result -eq 0 ]; then
            # Mostrar metadatos despuÃ©s
            epub_show_metadata "$OUTPUT_FILE" "$(msg METADATA_AFTER)" "$GREEN"

            # VerificaciÃ³n de hash
            if [ "$VERIFY_HASH" = true ]; then
                verify_hashes "$ORIGINAL_FILE" "$OUTPUT_FILE"
            fi

            # Resumen final
            print_separator
            echo -e "${STYLE_BOLD}${GREEN}${SPARKLES} $(msg PROCESS_COMPLETED)${NC}"
            print_separator
            echo ""
            echo -e "  ${FILE_ICON} $(msg ORIGINAL_FILE) ${GRAY}${ORIGINAL_FILE}${NC}"
            echo -e "  ${SPARKLES} $(msg CLEAN_FILE)   ${GREEN}${OUTPUT_FILE}${NC}"
            echo ""
            show_file_info "$OUTPUT_FILE"
            echo ""
            echo -e "${CYAN}${INFO} $(msg ORIGINAL_PRESERVED)${NC}"
            echo ""
        fi

        exit $epub_result
    fi

    # Dispatch a torrent mode si se detectÃ³ un archivo torrent
    if [ "$TORRENT_MODE" = true ]; then
        local script_dir="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
        local lib_dir="${script_dir}/lib"

        if [ ! -f "${lib_dir}/torrent_handler.sh" ]; then
            echo -e "${RED}${CROSS} Error: Torrent handler not found in ${lib_dir}${NC}" >&2
            exit 1
        fi

        # Exportar variables necesarias para torrent mode
        export RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY STYLE_BOLD NC
        export CHECK CROSS ARROW BULLET WARN INFO CLEAN SHIELD FILE_ICON SIZE_ICON
        export SPARKLES SEARCH_ICON TOOL_ICON
        export LANG_CODE DRY_RUN VERIFY_HASH SHOW_ONLY
        export TORRENT_MODE TORRENT_CLEAN_MODE

        # Exportar funciÃ³n msg
        export -f msg

        # Cargar torrent handler
        source "${lib_dir}/torrent_handler.sh"

        # Modo SHOW-ONLY para torrent
        if [ "$SHOW_ONLY" = true ]; then
            echo ""
            echo -e "${CYAN}${INFO} ${STYLE_BOLD}$(msg SHOW_ONLY_MODE)${NC}"
            echo -e "${GRAY}$(msg SHOW_ONLY_NOTICE)${NC}"
            torrent_show_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$CYAN"
            exit 0
        fi

        # Modo DRY-RUN para torrent
        if [ "$DRY_RUN" = true ]; then
            echo ""
            torrent_show_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$RED"
            echo ""
            echo -e "${CYAN}${INFO} $(msg WOULD_CREATE) ${GREEN}${OUTPUT_FILE}${NC}"
            echo -e "${GRAY}$(msg DRY_RUN_NOTICE)${NC}"
            exit 0
        fi

        # Mostrar metadatos antes
        torrent_show_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$RED"

        # Procesar torrent
        torrent_main "$ORIGINAL_FILE" "$OUTPUT_FILE"
        local torrent_result=$?

        if [ $torrent_result -eq 0 ]; then
            # Mostrar metadatos despuÃ©s
            torrent_show_metadata "$OUTPUT_FILE" "$(msg METADATA_AFTER)" "$GREEN"

            # VerificaciÃ³n de hash
            if [ "$VERIFY_HASH" = true ]; then
                verify_hashes "$ORIGINAL_FILE" "$OUTPUT_FILE"
            fi

            # Resumen final
            print_separator
            echo -e "${STYLE_BOLD}${GREEN}${SPARKLES} $(msg PROCESS_COMPLETED)${NC}"
            print_separator
            echo ""
            echo -e "  ${FILE_ICON} $(msg ORIGINAL_FILE) ${GRAY}${ORIGINAL_FILE}${NC}"
            echo -e "  ${SPARKLES} $(msg CLEAN_FILE)   ${GREEN}${OUTPUT_FILE}${NC}"
            echo ""
            show_file_info "$OUTPUT_FILE"
            echo ""
            echo -e "${CYAN}${INFO} $(msg ORIGINAL_PRESERVED)${NC}"
            echo ""
        fi

        exit $torrent_result
    fi

    # Dispatch a archive mode si se detectÃ³ un archivo comprimido
    if [ "$ARCHIVE_MODE" = true ]; then
        # Usar readlink -f para obtener path absoluto sin depender del directorio actual
        local script_dir="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
        local lib_dir="${script_dir}/lib"

        if [ ! -f "${lib_dir}/archive_handler.sh" ]; then
            echo -e "${RED}${CROSS} Error: Archive handler not found in ${lib_dir}${NC}" >&2
            exit 1
        fi

        # Exportar variables necesarias para archive mode
        export RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY STYLE_BOLD NC
        export CHECK CROSS ARROW BULLET WARN INFO CLEAN SHIELD FILE_ICON SIZE_ICON
        export VIDEO_ICON IMAGE_ICON PDF_ICON OFFICE_ICON SPARKLES SEARCH_ICON
        export LOCATION_ICON CAMERA_ICON COMPUTER_ICON CALENDAR_ICON TOOL_ICON
        export ARCHIVE_ICON
        export LANG_CODE DRY_RUN VERIFY_HASH
        export ARCHIVE_PASSWORD ARCHIVE_PREVIEW ARCHIVE_UNKNOWN_POLICY

        # Exportar funciÃ³n msg
        export -f msg

        # Cargar y ejecutar archive handler
        source "${lib_dir}/archive_handler.sh"

        # Configurar opciones
        ARCHIVE_DRY_RUN="$DRY_RUN"
        ARCHIVE_VERIFY="$VERIFY_HASH"

        if [ "$ARCHIVE_PREVIEW" = true ]; then
            ARCHIVE_DRY_RUN=true
        fi

        # Procesar archivo comprimido
        archive_main "$ORIGINAL_FILE" "$OUTPUT_FILE" "$ARCHIVE_PASSWORD"
        exit $?
    fi

    # DetecciÃ³n de duplicados (no aplica para CSS ni lightweight)
    if [ "$CHECK_DUPLICATES" = true ] && [ "$FILE_TYPE" != "$(msg CSS_FILE)" ] && [ "$LIGHTWEIGHT_MODE" != true ]; then
        if detect_duplicate "$ORIGINAL_FILE"; then
            echo ""
            echo -e "${YELLOW}${WARN} ${STYLE_BOLD}$(msg DUPLICATE_WARNING)${NC}"
            echo -e "${GRAY}$(msg DUPLICATE_REASON)${NC}"
            echo ""
        fi
    fi

    # Modo LIGHTWEIGHT: salida mÃ­nima (v2.3)
    if [ "$LIGHTWEIGHT_MODE" = true ]; then
        # Contar metadatos antes
        local fields_before=0
        if [ "$FILE_TYPE" = "$(msg CSS_FILE)" ]; then
            fields_before=$(perl -0777 -ne 'print scalar(() = m{/\*.*?\*/}gs)' "$ORIGINAL_FILE" 2>/dev/null || echo "0")
        else
            fields_before=$(count_metadata_fields "$ORIGINAL_FILE")
        fi

        # Realizar limpieza silenciosamente
        if [ "$IS_MULTIMEDIA" = true ]; then
            local temp_ffmpeg="${TEMP_DIR}/temp_ffmpeg_$(basename "$ORIGINAL_FILE")"
            ffmpeg -i "$ORIGINAL_FILE" -map_metadata -1 -fflags +bitexact -c copy "$temp_ffmpeg" -y &>/dev/null
            cp "$temp_ffmpeg" "$OUTPUT_FILE"
            exiftool -all= -overwrite_original "$OUTPUT_FILE" &>/dev/null
            rm -f "$temp_ffmpeg"
        elif [ "$FILE_TYPE" = "$(msg CSS_FILE)" ]; then
            perl -0777 -pe 's|/\*.*?\*/||gs' "$ORIGINAL_FILE" > "$OUTPUT_FILE" 2>/dev/null
        elif [ "$FILE_TYPE" = "$(msg SVG_FILE)" ]; then
            perl -0777 -pe 's|<metadata[^>]*>.*?</metadata>||gsi; s|<!--.*?-->||gs; s|<rdf:RDF[^>]*>.*?</rdf:RDF>||gsi;' "$ORIGINAL_FILE" > "$OUTPUT_FILE" 2>/dev/null
        else
            cp "$ORIGINAL_FILE" "$OUTPUT_FILE"
            exiftool -all= -overwrite_original "$OUTPUT_FILE" &>/dev/null
        fi

        # Contar metadatos despuÃ©s
        local fields_after=0
        if [ -f "$OUTPUT_FILE" ]; then
            if [ "$FILE_TYPE" = "$(msg CSS_FILE)" ]; then
                fields_after=$(perl -0777 -ne 'print scalar(() = m{/\*.*?\*/}gs)' "$OUTPUT_FILE" 2>/dev/null || echo "0")
            else
                fields_after=$(count_metadata_fields "$OUTPUT_FILE")
            fi
            lightweight_output "$ORIGINAL_FILE" "$OUTPUT_FILE" "$fields_before" "$fields_after" "success"
        else
            lightweight_output "$ORIGINAL_FILE" "Error creating output file" 0 0 "error"
            exit 1
        fi

        exit 0
    fi

    # Modo SHOW-ONLY: solo mostrar metadatos sin limpiar
    if [ "$SHOW_ONLY" = true ]; then
        echo ""
        echo -e "${CYAN}${INFO} ${STYLE_BOLD}$(msg SHOW_ONLY_MODE)${NC}"
        echo -e "${GRAY}$(msg SHOW_ONLY_NOTICE)${NC}"
        echo ""

        # Mostrar metadatos segÃºn tipo de archivo
        if [ "$FILE_TYPE" = "$(msg CSS_FILE)" ]; then
            show_css_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$CYAN"
        else
            show_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$CYAN"
        fi

        echo ""
        exit 0
    fi

    # Mostrar metadatos ANTES
    if [ "$FILE_TYPE" = "$(msg CSS_FILE)" ]; then
        show_css_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$RED"
    else
        show_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$RED"
    fi

    # En modo DRY-RUN, solo mostrar quÃ© se harÃ­a
    if [ "$DRY_RUN" = true ]; then
        echo ""
        print_separator
        echo -e "${CYAN}${INFO} $(msg WOULD_CREATE) ${GREEN}${OUTPUT_FILE}${NC}"
        print_separator
        echo ""
        echo -e "${GRAY}$(msg DRY_RUN_NOTICE)${NC}"
        echo ""
        exit 0
    fi

    # Realizar limpieza
    perform_cleaning "$ORIGINAL_FILE" "$OUTPUT_FILE"

    # Mostrar metadatos DESPUÃ‰S
    if [ "$FILE_TYPE" = "$(msg CSS_FILE)" ]; then
        show_css_metadata "$OUTPUT_FILE" "$(msg METADATA_AFTER)" "$GREEN"
    else
        show_metadata "$OUTPUT_FILE" "$(msg METADATA_AFTER)" "$GREEN"
    fi

    # VerificaciÃ³n de hash (si estÃ¡ habilitado)
    if [ "$VERIFY_HASH" = true ]; then
        verify_hashes "$ORIGINAL_FILE" "$OUTPUT_FILE"
    fi

    # Resumen final
    print_separator
    echo -e "${STYLE_BOLD}${GREEN}${SPARKLES} $(msg PROCESS_COMPLETED)${NC}"
    print_separator
    echo ""
    echo -e "  ${FILE_ICON} $(msg ORIGINAL_FILE) ${GRAY}${ORIGINAL_FILE}${NC}"
    echo -e "  ${SPARKLES} $(msg CLEAN_FILE)   ${GREEN}${OUTPUT_FILE}${NC}"
    echo ""
    show_file_info "$OUTPUT_FILE"
    echo ""
    echo -e "${CYAN}${INFO} $(msg ORIGINAL_PRESERVED)${NC}"
    echo ""

    # Log operaciÃ³n completada
    if declare -f log_operation_complete &>/dev/null; then
        log_operation_complete "$ORIGINAL_FILE" "$OUTPUT_FILE" "success"
    fi

    # Forensic reporting (v2.6)
    if [ "$FORENSIC_REPORT_ENABLED" = true ]; then
        if declare -f forensic_generate_report &>/dev/null; then
            forensic_generate_report "$ORIGINAL_FILE" "$OUTPUT_FILE" "success"
            echo -e "${CYAN}${INFO} $(msg FORENSIC_REPORT_GENERATED)${NC}"
        fi
    fi

    # Enviar notificaciÃ³n de Ã©xito
    if declare -f notify_success &>/dev/null; then
        notify_success "$ORIGINAL_FILE"
    fi

    # Finalizar sesiÃ³n de logging
    if declare -f log_session_end &>/dev/null; then
        log_session_end
    fi
}

# Ejecutar
main "$@"
