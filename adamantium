#!/bin/bash

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—
# â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘
# â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘
# â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
# â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘
# â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Deep metadata cleaning | The tool that excited Edward Snowden
# Full Mode: ExifTool + ffmpeg
# Version: 1.3
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -euo pipefail

# Colores
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly GRAY='\033[0;90m'
readonly BOLD='\033[1m'
readonly NC='\033[0m' # No Color

# Emojis y sÃ­mbolos
readonly CHECK="${GREEN}âœ…${NC}"
readonly CROSS="${RED}âŒ${NC}"
readonly ARROW="${CYAN}â†’${NC}"
readonly BULLET="${BLUE}â—${NC}"
readonly WARN="${YELLOW}âš ï¸${NC}"
readonly INFO="${CYAN}ğŸ’¡${NC}"
readonly CLEAN="${MAGENTA}ğŸ§¹${NC}"
readonly SHIELD="ğŸ›¡ï¸"
readonly FILE_ICON="ğŸ“"
readonly SIZE_ICON="ğŸ“Š"
readonly VIDEO_ICON="ğŸ¬"
readonly IMAGE_ICON="ğŸ–¼ï¸"
readonly PDF_ICON="ğŸ“„"
readonly OFFICE_ICON="ğŸ“"
readonly SPARKLES="âœ¨"
readonly SEARCH_ICON="ğŸ”"
readonly LOCATION_ICON="ğŸ“"
readonly CAMERA_ICON="ğŸ“·"
readonly COMPUTER_ICON="ğŸ’»"
readonly CALENDAR_ICON="ğŸ“…"
readonly TOOL_ICON="ğŸ”§"

# Variables globales
TEMP_DIR=""
ORIGINAL_FILE=""
OUTPUT_FILE=""
FILE_TYPE=""
IS_MULTIMEDIA=false
DRY_RUN=false
VERIFY_HASH=false
CHECK_DUPLICATES=true

# Variables para batch mode
BATCH_MODE=false
BATCH_JOBS=0
BATCH_PATTERNS=()
BATCH_RECURSIVE=false
BATCH_CONFIRM=true
BATCH_VERBOSE=false
BATCH_QUIET=false

# Variables para interactive mode
INTERACTIVE_MODE=false

# Versiones mÃ­nimas requeridas (se actualizan automÃ¡ticamente desde upstream)
REQUIRED_EXIFTOOL_VERSION="13.39"
REQUIRED_FFMPEG_VERSION="8.0"

# Archivo de cachÃ© para evitar verificar en cada ejecuciÃ³n
CACHE_FILE="$HOME/.adamantium_last_check"
CACHE_DURATION=86400  # 24 horas en segundos

# Variables de sistema
DISTRO=""
PACKAGE_MANAGER=""
PKG_INSTALL_CMD=""

# Variables de internacionalizaciÃ³n
LANG_CODE="en"  # Default: English

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SISTEMA DE INTERNACIONALIZACIÃ“N (i18n)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

detect_language() {
    # Detectar idioma del sistema desde variables de entorno
    local sys_lang="${LANG:-${LC_ALL:-en_US.UTF-8}}"

    if [[ "$sys_lang" =~ ^es ]]; then
        LANG_CODE="es"
    else
        LANG_CODE="en"
    fi
}

# Mensajes en espaÃ±ol
declare -A MSG_ES=(
    [ERROR_NO_FILE]="Error: Debes proporcionar un archivo"
    [USAGE]="Uso:"
    [EXAMPLES]="Ejemplos:"
    [OPTIONS]="Opciones:"
    [ERROR_FILE_NOT_EXISTS]="Error: El archivo '%s' no existe"
    [FILE_TO_PROCESS]="Archivo a procesar:"
    [TYPE_DETECTED]="Tipo detectado:"
    [PROCESSING]="Procesamiento:"
    [METADATA_BEFORE]="METADATOS ANTES DE LA LIMPIEZA"
    [METADATA_AFTER]="METADATOS DESPUÃ‰S DE LA LIMPIEZA"
    [STARTING_DEEP_CLEAN]="INICIANDO LIMPIEZA PROFUNDA"
    [CLEANING_WITH_EXIFTOOL]="Limpiando metadatos con"
    [DEEP_CLEAN_WITH_FFMPEG]="Limpieza profunda con"
    [REMOVING_METADATA_EXIFTOOL]="Eliminando metadatos con ExifTool"
    [REMOVING_CONTAINER_METADATA]="Eliminando metadatos del contenedor multimedia"
    [CLEANING_COMPLETED]="Limpieza completada exitosamente"
    [PROCESS_COMPLETED]="PROCESO COMPLETADO"
    [ORIGINAL_FILE]="Archivo original:"
    [CLEAN_FILE]="Archivo limpio:"
    [SIZE]="TamaÃ±o:"
    [ORIGINAL_PRESERVED]="El archivo original se ha preservado intacto"
    [NO_METADATA_FOUND]="No se encontraron metadatos"
    [METADATA_FIELDS_TOTAL]="Total de campos de metadatos:"
    [VERIFYING_EXIFTOOL]="Verificando ExifTool..."
    [VERIFYING_FFMPEG]="Verificando ffmpeg..."
    [EXIFTOOL_UPDATED]="ExifTool estÃ¡ actualizado"
    [FFMPEG_UPDATED]="ffmpeg estÃ¡ actualizado"
    [EXIFTOOL_OUTDATED]="ExifTool desactualizado:"
    [FFMPEG_OUTDATED]="ffmpeg desactualizado:"
    [UPDATING_FROM_REPOS]="Actualizando desde repositorios..."
    [UPDATED_TO]="actualizado a"
    [FROM_REPOS]="desde repositorios"
    [TRYING_SYSTEM_REPOS]="Intentando con repositorios del sistema (puede ser versiÃ³n anterior)..."
    [UPDATE_ERROR]="Error al actualizar"
    [CONTINUING_CURRENT]="Continuando con versiÃ³n actual..."
    [INSTALLING_FROM_SOURCE]="Instalando ExifTool"
    [FROM_SOURCE_SITE]="desde fuente (exiftool.org)..."
    [DOWNLOAD_ERROR]="Error al descargar ExifTool"
    [INSTALLED_FROM_SOURCE]="instalado correctamente desde fuente"
    [POST_INSTALL_ERROR]="Error en la verificaciÃ³n post-instalaciÃ³n"
    [HEADER_SUBTITLE]="Limpieza profunda de metadatos | La herramienta que emocionÃ³ a Edward Snowden"
    [MULTIMEDIA]="multimedia"
    [IMAGE]="imagen"
    [PDF]="pdf"
    [OFFICE_DOC]="documento office"
    [UNKNOWN]="desconocido"
    [EXIFTOOL_FFMPEG]="ExifTool + ffmpeg"
    [EXIFTOOL_ONLY]="ExifTool"
    [TOTAL]="Total"
    [SEPARATOR]="â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    [PACKAGE_MANAGER_NOT_DETECTED]="No se pudo detectar el gestor de paquetes"
    [DRY_RUN_MODE]="MODO SIMULACIÃ“N (DRY-RUN)"
    [DRY_RUN_NOTICE]="No se realizarÃ¡n cambios, solo previsualizaciÃ³n"
    [WOULD_CREATE]="Se crearÃ­a:"
    [HASH_VERIFICATION]="VERIFICACIÃ“N DE HASH"
    [HASH_ORIGINAL]="Hash original (SHA256):"
    [HASH_CLEAN]="Hash limpio (SHA256):"
    [HASH_DIFFERENT]="Los archivos son diferentes (limpieza exitosa)"
    [HASH_IDENTICAL]="ADVERTENCIA: Los hashes son idÃ©nticos (sin cambios)"
    [DUPLICATE_WARNING]="ADVERTENCIA: Este archivo parece ya estar limpio"
    [DUPLICATE_REASON]="No se encontraron metadatos sensibles"
    [DUPLICATE_CONTINUE]="Â¿Deseas continuar de todos modos?"
    [BATCH_MODE]="MODO POR LOTES"
    [BATCH_PROCESSING]="Procesamiento por lotes"
    [FILES_SELECTED]="archivos seleccionados"
    [FILES_FOUND]="Archivos encontrados"
    [SELECT_FILES]="Seleccionar archivos"
    [PATTERN]="PatrÃ³n"
    [JOBS]="Trabajos paralelos"
    [PROCESSING_FILE]="Procesando"
    [BATCH_SUMMARY]="RESUMEN DEL LOTE"
    [SUMMARY]="Resumen"
    [SUCCESSFUL]="Exitosos"
    [FAILED]="Fallidos"
    [ELAPSED_TIME]="Tiempo transcurrido"
    [AVERAGE_SPEED]="Velocidad promedio"
    [FILES_PER_SECOND]="archivos/seg"
    [INTERACTIVE_SELECT]="Usar TAB para seleccionar, ENTER para confirmar"
    [NO_FILES_MATCH]="No se encontraron archivos que coincidan con los patrones"
    [NO_FILES_TO_PROCESS]="No hay archivos para procesar"
    [SEARCHING_FILES]="Buscando archivos"
    [PROCEED_WITH_CLEANING]="Â¿Proceder con la limpieza?"
    [INTERACTIVE_WELCOME]="Bienvenido al modo interactivo de adamantium"
    [INTERACTIVE_MENU_TITLE]="MenÃº Principal"
    [INTERACTIVE_SINGLE_FILE]="Limpiar archivo individual"
    [INTERACTIVE_BATCH]="Procesamiento por lotes"
    [INTERACTIVE_SETTINGS]="ConfiguraciÃ³n"
    [INTERACTIVE_HELP]="Ayuda"
    [INTERACTIVE_ABOUT]="Acerca de"
    [INTERACTIVE_EXIT]="Salir"
    [INTERACTIVE_SELECT_OPTION]="Selecciona una opciÃ³n"
    [INTERACTIVE_GOODBYE]="Â¡Hasta luego! Tu privacidad estÃ¡ protegida."
    [INTERACTIVE_ENTER_PATH]="Introduce la ruta del directorio"
    [INTERACTIVE_SELECT_FILE]="Selecciona un archivo"
)

# Mensajes en inglÃ©s (idioma por defecto)
declare -A MSG_EN=(
    [ERROR_NO_FILE]="Error: You must provide a file"
    [USAGE]="Usage:"
    [EXAMPLES]="Examples:"
    [OPTIONS]="Options:"
    [ERROR_FILE_NOT_EXISTS]="Error: File '%s' does not exist"
    [FILE_TO_PROCESS]="File to process:"
    [TYPE_DETECTED]="Detected type:"
    [PROCESSING]="Processing:"
    [METADATA_BEFORE]="METADATA BEFORE CLEANING"
    [METADATA_AFTER]="METADATA AFTER CLEANING"
    [STARTING_DEEP_CLEAN]="STARTING DEEP CLEANING"
    [CLEANING_WITH_EXIFTOOL]="Cleaning metadata with"
    [DEEP_CLEAN_WITH_FFMPEG]="Deep cleaning with"
    [REMOVING_METADATA_EXIFTOOL]="Removing metadata with ExifTool"
    [REMOVING_CONTAINER_METADATA]="Removing multimedia container metadata"
    [CLEANING_COMPLETED]="Cleaning completed successfully"
    [PROCESS_COMPLETED]="PROCESS COMPLETED"
    [ORIGINAL_FILE]="Original file:"
    [CLEAN_FILE]="Clean file:"
    [SIZE]="Size:"
    [ORIGINAL_PRESERVED]="The original file has been preserved intact"
    [NO_METADATA_FOUND]="No metadata found"
    [METADATA_FIELDS_TOTAL]="Total metadata fields:"
    [VERIFYING_EXIFTOOL]="Verifying ExifTool..."
    [VERIFYING_FFMPEG]="Verifying ffmpeg..."
    [EXIFTOOL_UPDATED]="ExifTool is up to date"
    [FFMPEG_UPDATED]="ffmpeg is up to date"
    [EXIFTOOL_OUTDATED]="ExifTool outdated:"
    [FFMPEG_OUTDATED]="ffmpeg outdated:"
    [UPDATING_FROM_REPOS]="Updating from repositories..."
    [UPDATED_TO]="updated to"
    [FROM_REPOS]="from repositories"
    [TRYING_SYSTEM_REPOS]="Trying system repositories (may be older version)..."
    [UPDATE_ERROR]="Error updating"
    [CONTINUING_CURRENT]="Continuing with current version..."
    [INSTALLING_FROM_SOURCE]="Installing ExifTool"
    [FROM_SOURCE_SITE]="from source (exiftool.org)..."
    [DOWNLOAD_ERROR]="Error downloading ExifTool"
    [INSTALLED_FROM_SOURCE]="installed correctly from source"
    [POST_INSTALL_ERROR]="Post-installation verification error"
    [HEADER_SUBTITLE]="Deep metadata cleaning | The tool that excited Edward Snowden"
    [MULTIMEDIA]="multimedia"
    [IMAGE]="image"
    [PDF]="pdf"
    [OFFICE_DOC]="office document"
    [UNKNOWN]="unknown"
    [EXIFTOOL_FFMPEG]="ExifTool + ffmpeg"
    [EXIFTOOL_ONLY]="ExifTool"
    [TOTAL]="Total"
    [SEPARATOR]="â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    [PACKAGE_MANAGER_NOT_DETECTED]="Could not detect package manager"
    [DRY_RUN_MODE]="DRY-RUN MODE (SIMULATION)"
    [DRY_RUN_NOTICE]="No changes will be made, preview only"
    [WOULD_CREATE]="Would create:"
    [HASH_VERIFICATION]="HASH VERIFICATION"
    [HASH_ORIGINAL]="Original hash (SHA256):"
    [HASH_CLEAN]="Clean hash (SHA256):"
    [HASH_DIFFERENT]="Files are different (cleaning successful)"
    [HASH_IDENTICAL]="WARNING: Hashes are identical (no changes)"
    [DUPLICATE_WARNING]="WARNING: This file appears to be already clean"
    [DUPLICATE_REASON]="No sensitive metadata found"
    [DUPLICATE_CONTINUE]="Do you want to continue anyway?"
    [BATCH_MODE]="BATCH MODE"
    [BATCH_PROCESSING]="Batch processing"
    [FILES_SELECTED]="files selected"
    [FILES_FOUND]="Files found"
    [SELECT_FILES]="Select files"
    [PATTERN]="Pattern"
    [JOBS]="Parallel jobs"
    [PROCESSING_FILE]="Processing"
    [BATCH_SUMMARY]="BATCH SUMMARY"
    [SUMMARY]="Summary"
    [SUCCESSFUL]="Successful"
    [FAILED]="Failed"
    [ELAPSED_TIME]="Elapsed time"
    [AVERAGE_SPEED]="Average speed"
    [FILES_PER_SECOND]="files/sec"
    [INTERACTIVE_SELECT]="Use TAB to select, ENTER to confirm"
    [NO_FILES_MATCH]="No files match the patterns"
    [NO_FILES_TO_PROCESS]="No files to process"
    [SEARCHING_FILES]="Searching for files"
    [PROCEED_WITH_CLEANING]="Proceed with cleaning?"
    [INTERACTIVE_WELCOME]="Welcome to adamantium interactive mode"
    [INTERACTIVE_MENU_TITLE]="Main Menu"
    [INTERACTIVE_SINGLE_FILE]="Clean single file"
    [INTERACTIVE_BATCH]="Batch processing"
    [INTERACTIVE_SETTINGS]="Settings"
    [INTERACTIVE_HELP]="Help"
    [INTERACTIVE_ABOUT]="About"
    [INTERACTIVE_EXIT]="Exit"
    [INTERACTIVE_SELECT_OPTION]="Select an option"
    [INTERACTIVE_GOODBYE]="Goodbye! Your privacy is protected."
    [INTERACTIVE_ENTER_PATH]="Enter directory path"
    [INTERACTIVE_SELECT_FILE]="Select a file"
)

# FunciÃ³n para obtener mensaje traducido
msg() {
    local key="$1"
    shift
    local text

    if [ "$LANG_CODE" = "es" ]; then
        text="${MSG_ES[$key]}"
    else
        text="${MSG_EN[$key]}"
    fi

    # Si tiene parÃ¡metros, aplicar printf
    if [ $# -gt 0 ]; then
        printf "$text" "$@"
    else
        echo "$text"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DETECCIÃ“N DE DISTRIBUCIÃ“N Y GESTOR DE PAQUETES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

detect_system() {
    # Detectar distribuciÃ³n
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO="$ID"
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        DISTRO="$DISTRIB_ID"
    else
        DISTRO="unknown"
    fi

    # Detectar gestor de paquetes
    if command -v pacman &>/dev/null; then
        PACKAGE_MANAGER="pacman"
        PKG_INSTALL_CMD="sudo pacman -S --noconfirm"
    elif command -v apt-get &>/dev/null; then
        PACKAGE_MANAGER="apt"
        PKG_INSTALL_CMD="sudo apt-get install -y"
    elif command -v dnf &>/dev/null; then
        PACKAGE_MANAGER="dnf"
        PKG_INSTALL_CMD="sudo dnf install -y"
    elif command -v yum &>/dev/null; then
        PACKAGE_MANAGER="yum"
        PKG_INSTALL_CMD="sudo yum install -y"
    elif command -v zypper &>/dev/null; then
        PACKAGE_MANAGER="zypper"
        PKG_INSTALL_CMD="sudo zypper install -y"
    elif command -v apk &>/dev/null; then
        PACKAGE_MANAGER="apk"
        PKG_INSTALL_CMD="sudo apk add"
    else
        PACKAGE_MANAGER="unknown"
        PKG_INSTALL_CMD=""
    fi
}

get_package_name() {
    local pkg="$1"

    case "$pkg" in
        exiftool)
            case "$PACKAGE_MANAGER" in
                pacman) echo "perl-image-exiftool" ;;
                apt) echo "libimage-exiftool-perl" ;;
                dnf|yum) echo "perl-Image-ExifTool" ;;
                zypper) echo "exiftool" ;;
                apk) echo "exiftool" ;;
                *) echo "exiftool" ;;
            esac
            ;;
        ffmpeg)
            echo "ffmpeg"  # Mismo nombre en todas las distros
            ;;
        *)
            echo "$pkg"
            ;;
    esac
}

install_package() {
    local pkg="$1"
    local pkg_name=$(get_package_name "$pkg")

    if [ -z "$PKG_INSTALL_CMD" ]; then
        echo -e "${RED}${CROSS}${NC} $(msg PACKAGE_MANAGER_NOT_DETECTED)"
        return 1
    fi

    # Actualizar repos si es necesario
    case "$PACKAGE_MANAGER" in
        pacman)
            sudo pacman -Sy &>/dev/null
            ;;
        apt)
            sudo apt-get update &>/dev/null
            ;;
    esac

    # Instalar paquete
    $PKG_INSTALL_CMD "$pkg_name" &>/dev/null
    return $?
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE ACTUALIZACIÃ“N AUTOMÃTICA HÃBRIDA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

should_check_updates() {
    # Verificar si hace mÃ¡s de 24h desde la Ãºltima verificaciÃ³n
    if [ ! -f "$CACHE_FILE" ]; then
        return 0  # No existe cachÃ©, verificar
    fi

    local last_check=$(cat "$CACHE_FILE" 2>/dev/null || echo "0")
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_check))

    if [ "$time_diff" -gt "$CACHE_DURATION" ]; then
        return 0  # MÃ¡s de 24h, verificar
    else
        return 1  # Menos de 24h, skip
    fi
}

update_cache() {
    date +%s > "$CACHE_FILE"
}

get_latest_exiftool_version() {
    # Obtener Ãºltima versiÃ³n desde exiftool.org
    local version
    version=$(curl -s "https://exiftool.org/ver.txt" 2>/dev/null | head -1 | tr -d '\r\n' | grep -oP '[0-9]+\.[0-9]+')

    if [ -z "$version" ]; then
        # Fallback: parsear desde la pÃ¡gina principal
        version=$(curl -s "https://exiftool.org/" 2>/dev/null | grep -oP 'Version [0-9]+\.[0-9]+' | head -1 | grep -oP '[0-9]+\.[0-9]+')
    fi

    echo "${version:-$REQUIRED_EXIFTOOL_VERSION}"
}

compare_versions() {
    # Compara dos versiones en formato X.Y
    # Retorna 0 si $1 >= $2, 1 si $1 < $2
    local v1=$1
    local v2=$2

    if [ "$v1" = "$v2" ]; then
        return 0
    fi

    local v1_major=$(echo "$v1" | cut -d. -f1)
    local v1_minor=$(echo "$v1" | cut -d. -f2)
    local v2_major=$(echo "$v2" | cut -d. -f1)
    local v2_minor=$(echo "$v2" | cut -d. -f2)

    if [ "$v1_major" -gt "$v2_major" ]; then
        return 0
    elif [ "$v1_major" -lt "$v2_major" ]; then
        return 1
    fi

    # Major iguales, comparar minor
    if [ "$v1_minor" -ge "$v2_minor" ]; then
        return 0
    else
        return 1
    fi
}

install_exiftool_from_source() {
    local target_version=$1
    local temp_dir=$(mktemp -d)

    echo -e "${CYAN}${ARROW}${NC} $(msg INSTALLING_FROM_SOURCE) ${WHITE}${target_version}${NC} $(msg FROM_SOURCE_SITE)"

    cd "$temp_dir" || return 1

    # Descargar
    if ! wget -q "https://exiftool.org/Image-ExifTool-${target_version}.tar.gz" 2>/dev/null; then
        echo -e "${RED}${CROSS}${NC} $(msg DOWNLOAD_ERROR) ${target_version}"
        rm -rf "$temp_dir"
        return 1
    fi

    # Extraer
    tar -xzf "Image-ExifTool-${target_version}.tar.gz" || { rm -rf "$temp_dir"; return 1; }
    cd "Image-ExifTool-${target_version}" || { rm -rf "$temp_dir"; return 1; }

    # Instalar
    perl Makefile.PL &>/dev/null || { rm -rf "$temp_dir"; return 1; }
    make &>/dev/null || { rm -rf "$temp_dir"; return 1; }
    sudo make install &>/dev/null || { rm -rf "$temp_dir"; return 1; }

    # Limpiar
    cd /
    rm -rf "$temp_dir"

    # Verificar instalaciÃ³n
    local new_version=$(exiftool -ver 2>/dev/null || echo "error")
    if [ "$new_version" = "$target_version" ]; then
        echo -e "${GREEN}${CHECK}${NC} ExifTool ${WHITE}${target_version}${NC} $(msg INSTALLED_FROM_SOURCE)"
        return 0
    else
        echo -e "${RED}${CROSS}${NC} $(msg POST_INSTALL_ERROR)"
        return 1
    fi
}

check_and_update_dependencies() {
    # Verificar si debemos chequear actualizaciones (cachÃ© de 24h)
    if ! should_check_updates; then
        return 0
    fi

    local needs_update=false
    local exiftool_version=$(exiftool -ver 2>/dev/null || echo "0")
    local ffmpeg_version=$(ffmpeg -version 2>&1 | head -n1 | grep -oP 'version n?\K[0-9]+\.[0-9]+' | head -1 || echo "0")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # EXIFTOOL - Hybrid system (source first, package manager fallback)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    echo -e "${GRAY}$(msg VERIFYING_EXIFTOOL)${NC}"
    local latest_exiftool=$(get_latest_exiftool_version)

    if ! compare_versions "$exiftool_version" "$latest_exiftool"; then
        echo -e "${YELLOW}âš ${NC}  $(msg EXIFTOOL_OUTDATED) ${WHITE}${exiftool_version}${NC} â†’ ${CYAN}${latest_exiftool}${NC}"

        # Intentar instalar desde fuente (garantiza Ãºltima versiÃ³n)
        if install_exiftool_from_source "$latest_exiftool"; then
            needs_update=true
        else
            # Fallback: try with system package manager
            echo -e "${YELLOW}âš ${NC}  $(msg TRYING_SYSTEM_REPOS)"
            if install_package "exiftool"; then
                local new_version=$(exiftool -ver 2>/dev/null)
                echo -e "${GREEN}${CHECK}${NC} ExifTool $(msg UPDATED_TO) ${WHITE}${new_version}${NC} $(msg FROM_REPOS)"
                needs_update=true
            else
                echo -e "${RED}${CROSS}${NC} $(msg UPDATE_ERROR) ExifTool. $(msg CONTINUING_CURRENT)"
            fi
        fi
        echo ""
    else
        echo -e "${GREEN}${CHECK}${NC} ExifTool ${WHITE}${exiftool_version}${NC} $(msg EXIFTOOL_UPDATED)"
    fi

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FFMPEG - Repository only (compiling is very slow)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    echo -e "${GRAY}$(msg VERIFYING_FFMPEG)${NC}"

    if ! compare_versions "$ffmpeg_version" "$REQUIRED_FFMPEG_VERSION"; then
        echo -e "${YELLOW}âš ${NC}  $(msg FFMPEG_OUTDATED) ${WHITE}${ffmpeg_version}${NC} â†’ ${CYAN}${REQUIRED_FFMPEG_VERSION}+${NC}"
        echo -e "${CYAN}${ARROW}${NC} $(msg UPDATING_FROM_REPOS)"

        if install_package "ffmpeg"; then
            local new_version=$(ffmpeg -version 2>&1 | head -n1 | grep -oP 'version n?\K[0-9]+\.[0-9]+' | head -1)
            echo -e "${GREEN}${CHECK}${NC} ffmpeg $(msg UPDATED_TO) ${WHITE}${new_version}${NC}"
            needs_update=true
        else
            echo -e "${RED}${CROSS}${NC} $(msg UPDATE_ERROR) ffmpeg. $(msg CONTINUING_CURRENT)"
        fi
        echo ""
    else
        echo -e "${GREEN}${CHECK}${NC} ffmpeg ${WHITE}${ffmpeg_version}${NC} $(msg FFMPEG_UPDATED)"
    fi

    # Actualizar cachÃ©
    update_cache

    if [ "$needs_update" = true ]; then
        echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
        echo ""
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE UI
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print_header() {
    clear
    echo -e "${CYAN}"
    cat << "EOF"

   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—
  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘
  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘
  â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•

EOF
    echo -e "${NC}"
    echo -e "${GRAY}        $(msg HEADER_SUBTITLE)${NC}"
    echo -e "${GRAY}        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

print_separator() {
    echo -e "${GRAY}$(msg SEPARATOR)${NC}"
}

print_box() {
    local color="$1"
    local title="$2"
    local content="$3"

    echo -e "${color}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${NC}"
    echo -e "${color}â”‚${NC} ${BOLD}${title}${NC}"
    echo -e "${color}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
    echo -e "${content}" | while IFS= read -r line; do
        echo -e "${color}â”‚${NC} ${line}"
    done
    echo -e "${color}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}"
}

spinner() {
    local pid=$1
    local message=$2
    local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '

    tput civis # Ocultar cursor
    while kill -0 "$pid" 2>/dev/null; do
        local temp=${spinstr#?}
        printf "\r${CYAN}%s${NC} %s" "${spinstr:0:1}" "$message"
        spinstr=$temp${spinstr%"$temp"}
        sleep 0.1
    done
    tput cnorm # Mostrar cursor
    printf "\r${CHECK} %s\n" "$message"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE DETECCIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

detect_file_type() {
    local file="$1"
    local mimetype

    mimetype=$(file -b --mime-type "$file")

    local type_icon=""
    case "$mimetype" in
        video/*|audio/*)
            FILE_TYPE="$(msg MULTIMEDIA)"
            IS_MULTIMEDIA=true
            type_icon="$VIDEO_ICON"
            ;;
        image/*)
            FILE_TYPE="$(msg IMAGE)"
            IS_MULTIMEDIA=false
            type_icon="$IMAGE_ICON"
            ;;
        application/pdf)
            FILE_TYPE="$(msg PDF)"
            IS_MULTIMEDIA=false
            type_icon="$PDF_ICON"
            ;;
        application/vnd.openxmlformats-officedocument.*|application/vnd.oasis.opendocument.*)
            FILE_TYPE="$(msg OFFICE_DOC)"
            IS_MULTIMEDIA=false
            type_icon="$OFFICE_ICON"
            ;;
        application/msword|application/vnd.ms-*)
            FILE_TYPE="$(msg OFFICE_DOC)"
            IS_MULTIMEDIA=false
            type_icon="$OFFICE_ICON"
            ;;
        *)
            FILE_TYPE="$(msg UNKNOWN)"
            IS_MULTIMEDIA=false
            type_icon="$BULLET"
            ;;
    esac

    echo -e "  ${type_icon} $(msg TYPE_DETECTED): ${YELLOW}${FILE_TYPE}${NC} ${GRAY}(${mimetype})${NC}"
    echo -e "  ${TOOL_ICON} $(msg PROCESSING): ${CYAN}$([ "$IS_MULTIMEDIA" = true ] && msg EXIFTOOL_FFMPEG || msg EXIFTOOL_ONLY)${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE ANÃLISIS DE METADATOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_metadata() {
    local file="$1"
    local title="$2"
    local color="$3"

    echo ""
    echo -e "${color}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${color}â•‘${NC} ${BOLD}${SEARCH_ICON} ${title}${NC}"
    echo -e "${color}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    # Obtener TODOS los metadatos con exiftool (sin filtrar)
    local metadata
    metadata=$(exiftool "$file" 2>/dev/null)

    if [ -z "$metadata" ] || [ "$(echo "$metadata" | wc -l)" -le 1 ]; then
        echo -e "${GREEN}  ${CHECK} $(msg NO_METADATA_FOUND)${NC}"
        return
    fi

    # Campos sensibles a destacar en rojo
    local sensitive_patterns="Author|Creator|GPS|Location|Artist|Company|Owner|Serial|Parameters|Model|Software|Camera|Device|Make|Copyright|Last Modified By|User|Comment|Description|Subject|Keywords"

    # Campos tÃ©cnicos/fechas en amarillo
    local technical_patterns="Date|Time|Timestamp|Encoder|Codec|Compression|Version|Tool"

    # Campos bÃ¡sicos del sistema en gris (menos importantes visualmente)
    local system_patterns="ExifTool|File Name|Directory|File Size|File Permissions|File Inode|File Access Date"

    # Valores genÃ©ricos de Handler que NO son sensibles (estructura MP4 estÃ¡ndar)
    local generic_handler_values="VideoHandler|SoundHandler|DataHandler|SubtitleHandler|TextHandler|MetaHandler"

    local line_count=0
    local metadata_found=false

    # Mostrar TODOS los metadatos sin filtrar
    while IFS= read -r line; do
        # Saltar lÃ­neas vacÃ­as
        [ -z "$line" ] && continue

        # Verificar que la lÃ­nea tiene el formato "Key : Value"
        if echo "$line" | grep -q ":"; then
            metadata_found=true
            line_count=$((line_count + 1))

            local key=$(echo "$line" | cut -d: -f1 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
            local value=$(echo "$line" | cut -d: -f2- | sed 's/^[[:space:]]*//')

            # Colorear segÃºn nivel de sensibilidad
            # EXCEPCIÃ“N: Handler con valores genÃ©ricos â†’ AZUL (no sensible)
            if echo "$key" | grep -qi "Handler" && echo "$value" | grep -qE "(${generic_handler_values})"; then
                # AZUL: Handler genÃ©rico (estructura estÃ¡ndar MP4, no sensible)
                echo -e "  ${BLUE}â—${NC} ${CYAN}${key}:${NC} ${value}"
            elif echo "$key" | grep -qE "(${sensitive_patterns})"; then
                # ROJO: Metadatos sensibles (privacidad crÃ­tica)
                echo -e "  ${RED}â—${NC} ${RED}${key}:${NC} ${WHITE}${value}${NC}"
            elif echo "$key" | grep -qE "(${technical_patterns})"; then
                # AMARILLO: Metadatos tÃ©cnicos
                echo -e "  ${YELLOW}â—${NC} ${YELLOW}${key}:${NC} ${CYAN}${value}${NC}"
            elif echo "$key" | grep -qE "(${system_patterns})"; then
                # GRIS: Info del sistema (menos crÃ­tico)
                echo -e "  ${GRAY}â—${NC} ${GRAY}${key}:${NC} ${GRAY}${value}${NC}"
            else
                # AZUL: Resto de metadatos
                echo -e "  ${BLUE}â—${NC} ${CYAN}${key}:${NC} ${value}"
            fi
        fi
    done <<< "$metadata"

    if [ "$metadata_found" = false ]; then
        echo -e "${GREEN}  ${CHECK} $(msg NO_METADATA_FOUND)${NC}"
    else
        echo ""
        echo -e "${GRAY}  $(msg METADATA_FIELDS_TOTAL) ${WHITE}${line_count}${NC}"
    fi

    echo ""
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE HASH Y VERIFICACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

calculate_hash() {
    local file="$1"
    sha256sum "$file" 2>/dev/null | cut -d' ' -f1
}

detect_duplicate() {
    local file="$1"

    # Obtener metadatos
    local metadata
    metadata=$(exiftool "$file" 2>/dev/null)

    if [ -z "$metadata" ]; then
        return 1  # No se pudo leer, no es duplicado
    fi

    # Contar metadatos sensibles (excluyendo metadatos bÃ¡sicos del archivo)
    local sensitive_count
    sensitive_count=$(echo "$metadata" | grep -vE "ExifTool|File Name|Directory|File Size|File Permissions|File Inode|File Access Date|File Modification" | grep -c ":" || echo "0")

    # Si hay menos de 3 campos de metadatos (muy pocos), probablemente ya estÃ¡ limpio
    if [ "$sensitive_count" -lt 3 ]; then
        return 0  # Es un posible duplicado/ya limpio
    fi

    return 1  # No es duplicado
}

verify_hashes() {
    local original_file="$1"
    local clean_file="$2"

    echo ""
    print_separator
    echo -e "${BOLD}${CYAN}$(msg HASH_VERIFICATION)${NC}"
    print_separator
    echo ""

    local hash_original=$(calculate_hash "$original_file")
    local hash_clean=$(calculate_hash "$clean_file")

    echo -e "  ${CYAN}â—${NC} $(msg HASH_ORIGINAL)"
    echo -e "    ${GRAY}${hash_original}${NC}"
    echo ""
    echo -e "  ${CYAN}â—${NC} $(msg HASH_CLEAN)"
    echo -e "    ${GRAY}${hash_clean}${NC}"
    echo ""

    if [ "$hash_original" != "$hash_clean" ]; then
        echo -e "${GREEN}${CHECK}${NC} $(msg HASH_DIFFERENT)"
    else
        echo -e "${YELLOW}${WARN}${NC} $(msg HASH_IDENTICAL)"
    fi
    echo ""
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE LIMPIEZA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

clean_with_exiftool() {
    local input="$1"
    local output="$2"

    echo -e "${ARROW} $(msg CLEANING_WITH_EXIFTOOL) ${CYAN}ExifTool${NC}..."

    # Copiar archivo para preservar el original
    cp "$input" "$output"

    # Limpiar metadatos
    exiftool -all= -overwrite_original "$output" &>/dev/null &
    spinner $! "$(msg REMOVING_METADATA_EXIFTOOL)"

    return 0
}

clean_with_ffmpeg() {
    local input="$1"
    local output="$2"

    echo -e "${ARROW} $(msg DEEP_CLEAN_WITH_FFMPEG) ${CYAN}ffmpeg${NC}..."

    # Detectar si es audio o video
    local codec_copy="-c copy"

    # Limpiar metadatos del contenedor
    ffmpeg -i "$input" -map_metadata -1 -fflags +bitexact $codec_copy "$output" -y &>/dev/null &
    spinner $! "$(msg REMOVING_CONTAINER_METADATA)"

    return 0
}

perform_cleaning() {
    local input="$1"
    local output="$2"

    echo ""
    print_separator
    echo -e "${BOLD}${MAGENTA}$(msg STARTING_DEEP_CLEAN)${NC}"
    print_separator
    echo ""

    if [ "$IS_MULTIMEDIA" = true ]; then
        # Para multimedia: ffmpeg primero, luego exiftool
        local temp_ffmpeg="${TEMP_DIR}/temp_ffmpeg_$(basename "$input")"

        clean_with_ffmpeg "$input" "$temp_ffmpeg"
        clean_with_exiftool "$temp_ffmpeg" "$output"

        rm -f "$temp_ffmpeg"
    else
        # Para otros archivos: solo exiftool
        clean_with_exiftool "$input" "$output"
    fi

    echo ""
    echo -e "${GREEN}${SPARKLES} ${CHECK} $(msg CLEANING_COMPLETED)${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE COMPARACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_file_info() {
    local file="$1"
    local size
    local hash

    size=$(du -h "$file" | cut -f1)
    hash=$(sha256sum "$file" | cut -d' ' -f1 | cut -c1-16)

    echo -e "  ${SIZE_ICON} $(msg SIZE): ${CYAN}${size}${NC}"
    echo -e "  ${BULLET} SHA256: ${GRAY}${hash}...${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N PRINCIPAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cleanup() {
    if [ -n "$TEMP_DIR" ] && [ -d "$TEMP_DIR" ]; then
        rm -rf "$TEMP_DIR"
    fi
}

trap cleanup EXIT

main() {
    # Detectar idioma del sistema
    detect_language

    # Detectar sistema y gestor de paquetes
    detect_system

    # Parsear argumentos
    local file_arg=""
    local output_arg=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --batch)
                BATCH_MODE=true
                shift
                ;;
            --jobs|-j)
                BATCH_JOBS="$2"
                shift 2
                ;;
            --pattern)
                BATCH_PATTERNS+=("$2")
                shift 2
                ;;
            --recursive|-r)
                BATCH_RECURSIVE=true
                shift
                ;;
            --confirm)
                BATCH_CONFIRM=true
                shift
                ;;
            --no-confirm)
                BATCH_CONFIRM=false
                shift
                ;;
            --verbose|-v)
                BATCH_VERBOSE=true
                shift
                ;;
            --quiet|-q)
                BATCH_QUIET=true
                shift
                ;;
            --verify)
                VERIFY_HASH=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --no-duplicate-check)
                CHECK_DUPLICATES=false
                shift
                ;;
            --interactive|-i)
                INTERACTIVE_MODE=true
                shift
                ;;
            -h|--help)
                print_header
                echo -e "${BOLD}$(msg USAGE)${NC}"
                echo -e "  $0 [$(msg OPTIONS)] <file> [output_file]"
                echo -e "  $0 --batch --pattern PATTERN [$(msg OPTIONS)] [directory]"
                echo ""
                echo -e "${BOLD}$(msg OPTIONS)${NC}"
                echo -e "  ${CYAN}--verify${NC}              $(msg HASH_VERIFICATION | tr '[:upper:]' '[:lower:]')"
                echo -e "  ${CYAN}--dry-run${NC}             $(msg DRY_RUN_NOTICE | tr '[:upper:]' '[:lower:]')"
                echo -e "  ${CYAN}--no-duplicate-check${NC}  Skip duplicate detection"
                echo -e "  ${CYAN}--interactive, -i${NC}     Launch interactive TUI mode"
                echo -e "  ${CYAN}-h, --help${NC}            Show this help"
                echo ""
                echo -e "${BOLD}$(msg BATCH_MODE):${NC}"
                echo -e "  ${CYAN}--batch${NC}               Enable batch processing"
                echo -e "  ${CYAN}--pattern PATTERN${NC}     File pattern (can repeat, e.g., '*.jpg')"
                echo -e "  ${CYAN}--jobs N, -j N${NC}       Parallel jobs (default: auto-detect)"
                echo -e "  ${CYAN}--recursive, -r${NC}      Recursive directory search"
                echo -e "  ${CYAN}--confirm${NC}            Interactive file selection (default)"
                echo -e "  ${CYAN}--no-confirm${NC}         Skip confirmation (for automation)"
                echo -e "  ${CYAN}--verbose, -v${NC}        Verbose output"
                echo -e "  ${CYAN}--quiet, -q${NC}          Minimal output"
                echo ""
                echo -e "${BOLD}$(msg EXAMPLES)${NC}"
                echo -e "  ${GRAY}# Single file mode${NC}"
                echo -e "  $0 documento.pdf"
                echo -e "  $0 video.mp4 video_clean.mp4"
                echo -e "  $0 imagen.jpg --verify"
                echo -e "  $0 foto.png --dry-run"
                echo ""
                echo -e "  ${GRAY}# Batch mode${NC}"
                echo -e "  $0 --batch --pattern '*.jpg' ~/Photos"
                echo -e "  $0 --batch --pattern '*.jpg' --pattern '*.png' ."
                echo -e "  $0 --batch -r -j 8 --pattern '*.pdf' ~/Documents"
                echo -e "  $0 --batch --no-confirm --pattern '*.mp4' /media/videos"
                echo ""
                echo -e "  ${GRAY}# Interactive mode${NC}"
                echo -e "  $0 --interactive"
                echo -e "  $0 -i"
                echo ""
                exit 0
                ;;
            -*)
                echo -e "${RED}${CROSS} Unknown option: $1${NC}\n"
                echo -e "Use ${CYAN}--help${NC} for usage information"
                exit 1
                ;;
            *)
                if [ -z "$file_arg" ]; then
                    file_arg="$1"
                elif [ -z "$output_arg" ]; then
                    output_arg="$1"
                fi
                shift
                ;;
        esac
    done

    # Dispatch a interactive mode si estÃ¡ activado
    if [ "$INTERACTIVE_MODE" = true ]; then
        local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        local lib_dir="${script_dir}/lib"

        if [ ! -f "${lib_dir}/interactive_mode.sh" ]; then
            echo -e "${RED}${CROSS} Error: Interactive mode libraries not found in ${lib_dir}${NC}" >&2
            exit 1
        fi

        # Exportar variables necesarias para interactive mode
        export RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY BOLD NC
        export CHECK CROSS ARROW BULLET WARN INFO CLEAN SHIELD FILE_ICON SIZE_ICON
        export VIDEO_ICON IMAGE_ICON PDF_ICON OFFICE_ICON SPARKLES SEARCH_ICON
        export LOCATION_ICON CAMERA_ICON COMPUTER_ICON CALENDAR_ICON TOOL_ICON
        export LANG_CODE

        # Exportar funciones necesarias
        export -f msg
        export -f print_header

        # Cargar y ejecutar interactive mode
        source "${lib_dir}/interactive_mode.sh"
        interactive_main
        exit $?
    fi

    # Dispatch a batch mode si estÃ¡ activado
    if [ "$BATCH_MODE" = true ]; then
        # Determinar directorio lib
        local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        local lib_dir="${script_dir}/lib"

        # Cargar batch_core
        if [ ! -f "${lib_dir}/batch_core.sh" ]; then
            echo -e "${RED}${CROSS} Error: Batch libraries not found in ${lib_dir}${NC}" >&2
            exit 1
        fi

        # Exportar variables necesarias para batch
        export BATCH_MODE BATCH_JOBS BATCH_PATTERNS BATCH_RECURSIVE BATCH_CONFIRM BATCH_VERBOSE BATCH_QUIET
        export RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY BOLD NC
        export CHECK CROSS ARROW BULLET WARN INFO CLEAN SHIELD FILE_ICON SIZE_ICON
        export VIDEO_ICON IMAGE_ICON PDF_ICON OFFICE_ICON SPARKLES SEARCH_ICON
        export LOCATION_ICON CAMERA_ICON COMPUTER_ICON CALENDAR_ICON TOOL_ICON
        export LANG_CODE

        # Exportar funciÃ³n msg para que las librerÃ­as puedan usarla
        export -f msg

        # Cargar y ejecutar batch mode
        source "${lib_dir}/batch_core.sh"

        # Ejecutar con el directorio (o usar file_arg como directorio si existe)
        local target_dir="${file_arg:-.}"
        batch_main "$target_dir"
        exit $?
    fi

    # Verificar que se proporcionÃ³ un archivo
    if [ -z "$file_arg" ]; then
        print_header
        echo -e "${RED}${CROSS} $(msg ERROR_NO_FILE)${NC}\n"
        echo -e "${BOLD}$(msg USAGE)${NC}"
        echo -e "  $0 [options] <file> [output_file]"
        echo ""
        echo -e "${BOLD}$(msg EXAMPLES)${NC}"
        echo -e "  $0 documento.pdf"
        echo -e "  $0 video.mp4 video_clean.mp4"
        echo -e "  $0 imagen.jpg --verify"
        echo ""
        exit 1
    fi

    ORIGINAL_FILE="$file_arg"

    # Verificar que el archivo existe
    if [ ! -f "$ORIGINAL_FILE" ]; then
        print_header
        echo -e "${RED}${CROSS} $(msg ERROR_FILE_NOT_EXISTS "$ORIGINAL_FILE")${NC}\n"
        exit 1
    fi

    # Determinar archivo de salida
    if [ -n "$output_arg" ]; then
        OUTPUT_FILE="$output_arg"
    else
        local basename="${ORIGINAL_FILE%.*}"
        local extension="${ORIGINAL_FILE##*.}"
        OUTPUT_FILE="${basename}_clean.${extension}"
    fi

    # Crear directorio temporal
    TEMP_DIR=$(mktemp -d)

    # Verificar y actualizar dependencias automÃ¡ticamente
    check_and_update_dependencies

    # Mostrar interfaz
    print_header

    # Modo DRY-RUN
    if [ "$DRY_RUN" = true ]; then
        echo -e "${YELLOW}${WARN} ${BOLD}$(msg DRY_RUN_MODE)${NC}"
        echo -e "${GRAY}$(msg DRY_RUN_NOTICE)${NC}"
        echo ""
    fi

    echo -e "${BOLD}${FILE_ICON} $(msg FILE_TO_PROCESS)${NC}"
    echo -e "  ${ARROW} ${WHITE}${ORIGINAL_FILE}${NC}"
    show_file_info "$ORIGINAL_FILE"
    echo ""

    detect_file_type "$ORIGINAL_FILE"

    # DetecciÃ³n de duplicados
    if [ "$CHECK_DUPLICATES" = true ]; then
        if detect_duplicate "$ORIGINAL_FILE"; then
            echo ""
            echo -e "${YELLOW}${WARN} ${BOLD}$(msg DUPLICATE_WARNING)${NC}"
            echo -e "${GRAY}$(msg DUPLICATE_REASON)${NC}"
            echo ""
        fi
    fi

    # Mostrar metadatos ANTES
    show_metadata "$ORIGINAL_FILE" "$(msg METADATA_BEFORE)" "$RED"

    # En modo DRY-RUN, solo mostrar quÃ© se harÃ­a
    if [ "$DRY_RUN" = true ]; then
        echo ""
        print_separator
        echo -e "${CYAN}${INFO} $(msg WOULD_CREATE) ${GREEN}${OUTPUT_FILE}${NC}"
        print_separator
        echo ""
        echo -e "${GRAY}$(msg DRY_RUN_NOTICE)${NC}"
        echo ""
        exit 0
    fi

    # Realizar limpieza
    perform_cleaning "$ORIGINAL_FILE" "$OUTPUT_FILE"

    # Mostrar metadatos DESPUÃ‰S
    show_metadata "$OUTPUT_FILE" "$(msg METADATA_AFTER)" "$GREEN"

    # VerificaciÃ³n de hash (si estÃ¡ habilitado)
    if [ "$VERIFY_HASH" = true ]; then
        verify_hashes "$ORIGINAL_FILE" "$OUTPUT_FILE"
    fi

    # Resumen final
    print_separator
    echo -e "${BOLD}${GREEN}${SPARKLES} $(msg PROCESS_COMPLETED)${NC}"
    print_separator
    echo ""
    echo -e "  ${FILE_ICON} $(msg ORIGINAL_FILE) ${GRAY}${ORIGINAL_FILE}${NC}"
    echo -e "  ${SPARKLES} $(msg CLEAN_FILE)   ${GREEN}${OUTPUT_FILE}${NC}"
    echo ""
    show_file_info "$OUTPUT_FILE"
    echo ""
    echo -e "${CYAN}${INFO} $(msg ORIGINAL_PRESERVED)${NC}"
    echo ""
}

# Ejecutar
main "$@"
